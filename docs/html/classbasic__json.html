<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AlgoPlus: basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AlgoPlus
   &#160;<span id="projectnumber">v0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classbasic__json-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace for Niels Lohmann  
 <a href="classbasic__json.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="json_8hpp_source.html">json.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbasic__json.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a966e900415e66f3ab60f7b5ef52fd63b"><td class="memItemLeft" align="right" valign="top"><a id="a966e900415e66f3ab60f7b5ef52fd63b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_t</b> = <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">detail::value_t</a></td></tr>
<tr class="separator:a966e900415e66f3ab60f7b5ef52fd63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe66720a34c11920f359394a4430a16e"><td class="memItemLeft" align="right" valign="top"><a id="afe66720a34c11920f359394a4430a16e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> = ::nlohmann::json_pointer&lt; StringType &gt;</td></tr>
<tr class="memdesc:afe66720a34c11920f359394a4430a16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON Pointer, see nlohmann::json_pointer. <br /></td></tr>
<tr class="separator:afe66720a34c11920f359394a4430a16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75fd791f0b8fca724e5ed70b4956414"><td class="memTemplParams" colspan="2"><a id="ab75fd791f0b8fca724e5ed70b4956414"></a>
template&lt;typename T , typename SFINAE &gt; </td></tr>
<tr class="memitem:ab75fd791f0b8fca724e5ed70b4956414"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>json_serializer</b> = JSONSerializer&lt; T, SFINAE &gt;</td></tr>
<tr class="separator:ab75fd791f0b8fca724e5ed70b4956414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebde9badb4f1b4cf6517f6b8e302d0d"><td class="memItemLeft" align="right" valign="top"><a id="a2ebde9badb4f1b4cf6517f6b8e302d0d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2ebde9badb4f1b4cf6517f6b8e302d0d">error_handler_t</a> = <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">detail::error_handler_t</a></td></tr>
<tr class="memdesc:a2ebde9badb4f1b4cf6517f6b8e302d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">how to treat decoding errors <br /></td></tr>
<tr class="separator:a2ebde9badb4f1b4cf6517f6b8e302d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067b4f0e63e55055272fec0a26b5b991"><td class="memItemLeft" align="right" valign="top"><a id="a067b4f0e63e55055272fec0a26b5b991"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a067b4f0e63e55055272fec0a26b5b991">cbor_tag_handler_t</a> = <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">detail::cbor_tag_handler_t</a></td></tr>
<tr class="memdesc:a067b4f0e63e55055272fec0a26b5b991"><td class="mdescLeft">&#160;</td><td class="mdescRight">how to treat CBOR tags <br /></td></tr>
<tr class="separator:a067b4f0e63e55055272fec0a26b5b991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f7c93f896d302ed0b62d983aac53c0"><td class="memItemLeft" align="right" valign="top"><a id="a21f7c93f896d302ed0b62d983aac53c0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> = std::initializer_list&lt; <a class="el" href="classdetail_1_1json__ref.html">detail::json_ref</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt;</td></tr>
<tr class="memdesc:a21f7c93f896d302ed0b62d983aac53c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper type for initializer lists of <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> values <br /></td></tr>
<tr class="separator:a21f7c93f896d302ed0b62d983aac53c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143e447269d8beb1d02400093eccd018"><td class="memItemLeft" align="right" valign="top"><a id="a143e447269d8beb1d02400093eccd018"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>input_format_t</b> = <a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">detail::input_format_t</a></td></tr>
<tr class="separator:a143e447269d8beb1d02400093eccd018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefb05e1022be791038db86c9963cec7"><td class="memItemLeft" align="right" valign="top"><a id="acefb05e1022be791038db86c9963cec7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#acefb05e1022be791038db86c9963cec7">json_sax_t</a> = <a class="el" href="structjson__sax.html">json_sax</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:acefb05e1022be791038db86c9963cec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SAX interface type, see nlohmann::json_sax. <br /></td></tr>
<tr class="separator:acefb05e1022be791038db86c9963cec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b6bf8ee18c48f4609c8bdd4bb95107"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a53b6bf8ee18c48f4609c8bdd4bb95107">parse_event_t</a> = <a class="el" href="namespacedetail.html#a47b1bb0bbd3596589ed9187059c312ef">detail::parse_event_t</a></td></tr>
<tr class="memdesc:a53b6bf8ee18c48f4609c8bdd4bb95107"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser event types  <a href="classbasic__json.html#a53b6bf8ee18c48f4609c8bdd4bb95107">More...</a><br /></td></tr>
<tr class="separator:a53b6bf8ee18c48f4609c8bdd4bb95107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50644d655c9283aaf0e2a0f3a5428867"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a50644d655c9283aaf0e2a0f3a5428867">parser_callback_t</a> = detail::parser_callback_t&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a50644d655c9283aaf0e2a0f3a5428867"><td class="mdescLeft">&#160;</td><td class="mdescRight">per-element parser callback type  <a href="classbasic__json.html#a50644d655c9283aaf0e2a0f3a5428867">More...</a><br /></td></tr>
<tr class="separator:a50644d655c9283aaf0e2a0f3a5428867"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afb684c446c48759336dc227f16b7d3f4"><td class="memItemLeft" align="right" valign="top">JSON_HEDLEY_RETURNS_NON_NULL const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afb684c446c48759336dc227f16b7d3f4">type_name</a> () const noexcept</td></tr>
<tr class="memdesc:afb684c446c48759336dc227f16b7d3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the type as string  <a href="classbasic__json.html#afb684c446c48759336dc227f16b7d3f4">More...</a><br /></td></tr>
<tr class="separator:afb684c446c48759336dc227f16b7d3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b684342f67317a21b2d9e33ec8feb0"><td class="memItemLeft" align="right" valign="top"><a id="ab4b684342f67317a21b2d9e33ec8feb0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> v)</td></tr>
<tr class="separator:ab4b684342f67317a21b2d9e33ec8feb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2430d63f0ffd335f276c085c33c11b17"><td class="memItemLeft" align="right" valign="top"><a id="a2430d63f0ffd335f276c085c33c11b17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (<a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> cnt, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="separator:a2430d63f0ffd335f276c085c33c11b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8aaf6afe755ea6c586ab9920389d6bf"><td class="memItemLeft" align="right" valign="top"><a id="ac8aaf6afe755ea6c586ab9920389d6bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () noexcept=default</td></tr>
<tr class="separator:ac8aaf6afe755ea6c586ab9920389d6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ad05755736ab9e3416f0556bb47a6a"><td class="memItemLeft" align="right" valign="top"><a id="a08ad05755736ab9e3416f0556bb47a6a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (data &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a08ad05755736ab9e3416f0556bb47a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416abf41e6c61061dd2be762a88cceb8"><td class="memItemLeft" align="right" valign="top"><a id="a416abf41e6c61061dd2be762a88cceb8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (const data &amp;) noexcept=delete</td></tr>
<tr class="separator:a416abf41e6c61061dd2be762a88cceb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b114795c5e45d242a88d3e2306114c"><td class="memItemLeft" align="right" valign="top"><a id="ac8b114795c5e45d242a88d3e2306114c"></a>
data &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (data &amp;&amp;) noexcept=delete</td></tr>
<tr class="separator:ac8b114795c5e45d242a88d3e2306114c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345d693c6d7e58a3e486a4436d60956a"><td class="memItemLeft" align="right" valign="top"><a id="a345d693c6d7e58a3e486a4436d60956a"></a>
data &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const data &amp;) noexcept=delete</td></tr>
<tr class="separator:a345d693c6d7e58a3e486a4436d60956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4bceecf563151eb58af179416d8e6299"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbasic__json.html#a83f845db2d54cedad97279bad70aea52">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4bceecf563151eb58af179416d8e6299">get_allocator</a> ()</td></tr>
<tr class="memdesc:a4bceecf563151eb58af179416d8e6299"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the allocator associated with the container  <a href="classbasic__json.html#a4bceecf563151eb58af179416d8e6299">More...</a><br /></td></tr>
<tr class="separator:a4bceecf563151eb58af179416d8e6299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b435c2ed2db99cb1daa78ae3c6c4580"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7b435c2ed2db99cb1daa78ae3c6c4580">meta</a> ()</td></tr>
<tr class="memdesc:a7b435c2ed2db99cb1daa78ae3c6c4580"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns version information on the library  <a href="classbasic__json.html#a7b435c2ed2db99cb1daa78ae3c6c4580">More...</a><br /></td></tr>
<tr class="separator:a7b435c2ed2db99cb1daa78ae3c6c4580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addedd5e53fa6eff6cd621f1615741c3d"><td class="memItemLeft" align="right" valign="top"><a id="addedd5e53fa6eff6cd621f1615741c3d"></a>
JSON_PRIVATE_UNLESS_TESTED <a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> bool static SAX bool&#160;</td><td class="memItemRight" valign="bottom"><b>sax_parse</b> (InputType &amp;&amp;i, SAX *sax, <a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a> format=input_format_t::json, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="separator:addedd5e53fa6eff6cd621f1615741c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cbf1844fef86e9301282ad8ca0f822"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , class SAX &gt; </td></tr>
<tr class="memitem:a94cbf1844fef86e9301282ad8ca0f822"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a94cbf1844fef86e9301282ad8ca0f822">sax_parse</a> (IteratorType first, IteratorType last, SAX *sax, <a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a> format=input_format_t::json, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:a94cbf1844fef86e9301282ad8ca0f822"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate SAX events  <a href="classbasic__json.html#a94cbf1844fef86e9301282ad8ca0f822">More...</a><br /></td></tr>
<tr class="separator:a94cbf1844fef86e9301282ad8ca0f822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad018e709338c810c56eaad606186a77e"><td class="memTemplParams" colspan="2">template&lt;typename SAX &gt; </td></tr>
<tr class="memitem:ad018e709338c810c56eaad606186a77e"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad018e709338c810c56eaad606186a77e">sax_parse</a> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, SAX *sax, <a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a> format=input_format_t::json, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:ad018e709338c810c56eaad606186a77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate SAX events  <a href="classbasic__json.html#ad018e709338c810c56eaad606186a77e">More...</a><br /></td></tr>
<tr class="separator:ad018e709338c810c56eaad606186a77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a27054edf6738852b42e0218fe4337e1c"><td class="memItemLeft" align="right" valign="top"><a id="a27054edf6738852b42e0218fe4337e1c"></a>
JSON_PRIVATE_UNLESS_TESTED&#160;</td><td class="memItemRight" valign="bottom"><b>__pad4__</b>: struct data { <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> m_type = <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632a37a6259cc0c1dae299a7866489dff0bd">value_t::null</a></td></tr>
<tr class="separator:a27054edf6738852b42e0218fe4337e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0f167153f047a246b51858d7c921b8"><td class="memItemLeft" align="right" valign="top"><a id="acd0f167153f047a246b51858d7c921b8"></a>
json_value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#acd0f167153f047a246b51858d7c921b8">m_value</a> = {}</td></tr>
<tr class="memdesc:acd0f167153f047a246b51858d7c921b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">the value of the current element <br /></td></tr>
<tr class="separator:acd0f167153f047a246b51858d7c921b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7fd3c3afd2abb77797652506ab6bc0"><td class="memItemLeft" align="right" valign="top"><a id="a4f7fd3c3afd2abb77797652506ab6bc0"></a>
data&#160;</td><td class="memItemRight" valign="bottom"><b>m_data</b> = {}</td></tr>
<tr class="separator:a4f7fd3c3afd2abb77797652506ab6bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6275ed57bae6866cdf5db5370a7ad47c"><td class="memTemplParams" colspan="2"><a id="a6275ed57bae6866cdf5db5370a7ad47c"></a>
template&lt;detail::value_t &gt; </td></tr>
<tr class="memitem:a6275ed57bae6866cdf5db5370a7ad47c"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>detail::external_constructor</b></td></tr>
<tr class="separator:a6275ed57bae6866cdf5db5370a7ad47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f901b14cf3f7135269b0c75c9ac233"><td class="memTemplParams" colspan="2"><a id="a43f901b14cf3f7135269b0c75c9ac233"></a>
template&lt;typename &gt; </td></tr>
<tr class="memitem:a43f901b14cf3f7135269b0c75c9ac233"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>::nlohmann::json_pointer</b></td></tr>
<tr class="separator:a43f901b14cf3f7135269b0c75c9ac233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f3125911eb018ef4ab00d879487baf"><td class="memTemplParams" colspan="2"><a id="ac8f3125911eb018ef4ab00d879487baf"></a>
template&lt;typename BasicJsonType , typename InputType &gt; </td></tr>
<tr class="memitem:ac8f3125911eb018ef4ab00d879487baf"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>::nlohmann::detail::parser</b></td></tr>
<tr class="separator:ac8f3125911eb018ef4ab00d879487baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842e5c7ca096025c18b11e715d3401f4"><td class="memTemplParams" colspan="2"><a id="a842e5c7ca096025c18b11e715d3401f4"></a>
template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a842e5c7ca096025c18b11e715d3401f4"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>::nlohmann::detail::iter_impl</b></td></tr>
<tr class="separator:a842e5c7ca096025c18b11e715d3401f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d491bbda88ade6d3c7a2b11309e8bf"><td class="memTemplParams" colspan="2"><a id="a69d491bbda88ade6d3c7a2b11309e8bf"></a>
template&lt;typename BasicJsonType , typename CharType &gt; </td></tr>
<tr class="memitem:a69d491bbda88ade6d3c7a2b11309e8bf"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>::nlohmann::detail::binary_writer</b></td></tr>
<tr class="separator:a69d491bbda88ade6d3c7a2b11309e8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa226ed5103dfd10e27e562d35a3a106b"><td class="memTemplParams" colspan="2"><a id="aa226ed5103dfd10e27e562d35a3a106b"></a>
template&lt;typename BasicJsonType , typename InputType , typename SAX &gt; </td></tr>
<tr class="memitem:aa226ed5103dfd10e27e562d35a3a106b"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>::nlohmann::detail::binary_reader</b></td></tr>
<tr class="separator:aa226ed5103dfd10e27e562d35a3a106b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47aabb1eceae32e8a6e8e7f0ff34be60"><td class="memTemplParams" colspan="2"><a id="a47aabb1eceae32e8a6e8e7f0ff34be60"></a>
template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a47aabb1eceae32e8a6e8e7f0ff34be60"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>::nlohmann::detail::json_sax_dom_parser</b></td></tr>
<tr class="separator:a47aabb1eceae32e8a6e8e7f0ff34be60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95574da8d12905ea99dc348934c837da"><td class="memTemplParams" colspan="2"><a id="a95574da8d12905ea99dc348934c837da"></a>
template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a95574da8d12905ea99dc348934c837da"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>::nlohmann::detail::json_sax_dom_callback_parser</b></td></tr>
<tr class="separator:a95574da8d12905ea99dc348934c837da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcb15d025676b4d3db0f32a50f4393f"><td class="memItemLeft" align="right" valign="top"><a id="abdcb15d025676b4d3db0f32a50f4393f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>::nlohmann::detail::exception</b></td></tr>
<tr class="separator:abdcb15d025676b4d3db0f32a50f4393f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ca396028b8d9714c6e10efbf475af6"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a60ca396028b8d9714c6e10efbf475af6">operator&lt;&lt;</a> (<a class="el" href="classbasic__json.html">basic_json</a> &amp;j, std::istream &amp;i)</td></tr>
<tr class="memdesc:a60ca396028b8d9714c6e10efbf475af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="classbasic__json.html#a60ca396028b8d9714c6e10efbf475af6">More...</a><br /></td></tr>
<tr class="separator:a60ca396028b8d9714c6e10efbf475af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf363408931d76472ded14017e59c9e8"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aaf363408931d76472ded14017e59c9e8">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:aaf363408931d76472ded14017e59c9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <a href="classbasic__json.html#aaf363408931d76472ded14017e59c9e8">More...</a><br /></td></tr>
<tr class="separator:aaf363408931d76472ded14017e59c9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">element access</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf68418821a90b03a001117a613b131dd"></a>Access to the JSON value. </p>
</td></tr>
<tr class="memitem:a899e4623fe377af5c9ad14c40c64280c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a899e4623fe377af5c9ad14c40c64280c">at</a> (<a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> idx)</td></tr>
<tr class="memdesc:a899e4623fe377af5c9ad14c40c64280c"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element with bounds checking  <a href="classbasic__json.html#a899e4623fe377af5c9ad14c40c64280c">More...</a><br /></td></tr>
<tr class="separator:a899e4623fe377af5c9ad14c40c64280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af076d8a80f4263cf821da2033d5773b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af076d8a80f4263cf821da2033d5773b6">at</a> (<a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> idx) const</td></tr>
<tr class="memdesc:af076d8a80f4263cf821da2033d5773b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element with bounds checking  <a href="classbasic__json.html#af076d8a80f4263cf821da2033d5773b6">More...</a><br /></td></tr>
<tr class="separator:af076d8a80f4263cf821da2033d5773b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accafaaf23f60bb245ddb1fa0972b33a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#accafaaf23f60bb245ddb1fa0972b33a3">at</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:accafaaf23f60bb245ddb1fa0972b33a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <a href="classbasic__json.html#accafaaf23f60bb245ddb1fa0972b33a3">More...</a><br /></td></tr>
<tr class="separator:accafaaf23f60bb245ddb1fa0972b33a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd9ba2f2164d9cee83b07f76d40843f"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4cd9ba2f2164d9cee83b07f76d40843f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4cd9ba2f2164d9cee83b07f76d40843f">at</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:a4cd9ba2f2164d9cee83b07f76d40843f"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <a href="classbasic__json.html#a4cd9ba2f2164d9cee83b07f76d40843f">More...</a><br /></td></tr>
<tr class="separator:a4cd9ba2f2164d9cee83b07f76d40843f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9a21714e81e98fc5786a2339ea1665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aba9a21714e81e98fc5786a2339ea1665">at</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:aba9a21714e81e98fc5786a2339ea1665"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <a href="classbasic__json.html#aba9a21714e81e98fc5786a2339ea1665">More...</a><br /></td></tr>
<tr class="separator:aba9a21714e81e98fc5786a2339ea1665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae6267ca4bd85e25f61dc5ba30204da"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7ae6267ca4bd85e25f61dc5ba30204da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7ae6267ca4bd85e25f61dc5ba30204da">at</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:a7ae6267ca4bd85e25f61dc5ba30204da"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <a href="classbasic__json.html#a7ae6267ca4bd85e25f61dc5ba30204da">More...</a><br /></td></tr>
<tr class="separator:a7ae6267ca4bd85e25f61dc5ba30204da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f511db82b9d5eba85d5b2b8e1c6dbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab4f511db82b9d5eba85d5b2b8e1c6dbb">operator[]</a> (<a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> idx)</td></tr>
<tr class="memdesc:ab4f511db82b9d5eba85d5b2b8e1c6dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element  <a href="classbasic__json.html#ab4f511db82b9d5eba85d5b2b8e1c6dbb">More...</a><br /></td></tr>
<tr class="separator:ab4f511db82b9d5eba85d5b2b8e1c6dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae369d1565482903c3af75bf99467776b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae369d1565482903c3af75bf99467776b">operator[]</a> (<a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> idx) const</td></tr>
<tr class="memdesc:ae369d1565482903c3af75bf99467776b"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element  <a href="classbasic__json.html#ae369d1565482903c3af75bf99467776b">More...</a><br /></td></tr>
<tr class="separator:ae369d1565482903c3af75bf99467776b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5825034534bf9256a33d2dd995c25a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9c5825034534bf9256a33d2dd995c25a">operator[]</a> (typename object_t::key_type key)</td></tr>
<tr class="memdesc:a9c5825034534bf9256a33d2dd995c25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <a href="classbasic__json.html#a9c5825034534bf9256a33d2dd995c25a">More...</a><br /></td></tr>
<tr class="separator:a9c5825034534bf9256a33d2dd995c25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3ea17617e94886f3e86ac921095a13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3d3ea17617e94886f3e86ac921095a13">operator[]</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:a3d3ea17617e94886f3e86ac921095a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <a href="classbasic__json.html#a3d3ea17617e94886f3e86ac921095a13">More...</a><br /></td></tr>
<tr class="separator:a3d3ea17617e94886f3e86ac921095a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cae3810ae0a9c56b17842b06fc405e"><td class="memTemplParams" colspan="2"><a id="a87cae3810ae0a9c56b17842b06fc405e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87cae3810ae0a9c56b17842b06fc405e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator[]</b> (T *key)</td></tr>
<tr class="separator:a87cae3810ae0a9c56b17842b06fc405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12a4386e6913012ca4dffa0245fdf99"><td class="memTemplParams" colspan="2"><a id="ab12a4386e6913012ca4dffa0245fdf99"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab12a4386e6913012ca4dffa0245fdf99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator[]</b> (T *key) const</td></tr>
<tr class="separator:ab12a4386e6913012ca4dffa0245fdf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fe1a1c7aa8c193c73aa40b17ee5f68"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a06fe1a1c7aa8c193c73aa40b17ee5f68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a06fe1a1c7aa8c193c73aa40b17ee5f68">operator[]</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:a06fe1a1c7aa8c193c73aa40b17ee5f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <a href="classbasic__json.html#a06fe1a1c7aa8c193c73aa40b17ee5f68">More...</a><br /></td></tr>
<tr class="separator:a06fe1a1c7aa8c193c73aa40b17ee5f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e11a3f2a234cd296b515173b6a3b986"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2e11a3f2a234cd296b515173b6a3b986"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2e11a3f2a234cd296b515173b6a3b986">operator[]</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:a2e11a3f2a234cd296b515173b6a3b986"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <a href="classbasic__json.html#a2e11a3f2a234cd296b515173b6a3b986">More...</a><br /></td></tr>
<tr class="separator:a2e11a3f2a234cd296b515173b6a3b986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c2436388fd16a1529ce9afce8229ef"><td class="memTemplParams" colspan="2">template&lt;class ValueType , detail::enable_if_t&lt; !detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a80c2436388fd16a1529ce9afce8229ef"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> (const typename object_t::key_type &amp;key, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:a80c2436388fd16a1529ce9afce8229ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with default value  <a href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">More...</a><br /></td></tr>
<tr class="separator:a80c2436388fd16a1529ce9afce8229ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56244e0ed0943ad62faf61b06e7ba139"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; !detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a56244e0ed0943ad62faf61b06e7ba139"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a56244e0ed0943ad62faf61b06e7ba139">value</a> (const typename object_t::key_type &amp;key, ValueType &amp;&amp;default_value) const</td></tr>
<tr class="memdesc:a56244e0ed0943ad62faf61b06e7ba139"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with default value  <a href="classbasic__json.html#a56244e0ed0943ad62faf61b06e7ba139">More...</a><br /></td></tr>
<tr class="separator:a56244e0ed0943ad62faf61b06e7ba139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe572bbfbd4687a7a9167465e4d41f2"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class KeyType , detail::enable_if_t&lt; detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;!detail::is_json_pointer&lt; KeyType &gt;::value &amp;&amp;is_comparable_with_object_key&lt; KeyType &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:acbe572bbfbd4687a7a9167465e4d41f2"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#acbe572bbfbd4687a7a9167465e4d41f2">value</a> (KeyType &amp;&amp;key, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:acbe572bbfbd4687a7a9167465e4d41f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with default value  <a href="classbasic__json.html#acbe572bbfbd4687a7a9167465e4d41f2">More...</a><br /></td></tr>
<tr class="separator:acbe572bbfbd4687a7a9167465e4d41f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694398741710ce1c22797ad47109898b"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class KeyType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;!detail::is_json_pointer&lt; KeyType &gt;::value &amp;&amp;is_comparable_with_object_key&lt; KeyType &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a694398741710ce1c22797ad47109898b"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a694398741710ce1c22797ad47109898b">value</a> (KeyType &amp;&amp;key, ValueType &amp;&amp;default_value) const</td></tr>
<tr class="memdesc:a694398741710ce1c22797ad47109898b"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element via JSON Pointer with default value  <a href="classbasic__json.html#a694398741710ce1c22797ad47109898b">More...</a><br /></td></tr>
<tr class="separator:a694398741710ce1c22797ad47109898b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63045992eb552c11f77fefddd801591"><td class="memTemplParams" colspan="2">template&lt;class ValueType , detail::enable_if_t&lt; detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac63045992eb552c11f77fefddd801591"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac63045992eb552c11f77fefddd801591">value</a> (const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;ptr, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:ac63045992eb552c11f77fefddd801591"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element via JSON Pointer with default value  <a href="classbasic__json.html#ac63045992eb552c11f77fefddd801591">More...</a><br /></td></tr>
<tr class="separator:ac63045992eb552c11f77fefddd801591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab7b5edf8e5831195940f8d377a6ee3"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; detail::is_getable&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1ab7b5edf8e5831195940f8d377a6ee3"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1ab7b5edf8e5831195940f8d377a6ee3">value</a> (const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;ptr, ValueType &amp;&amp;default_value) const</td></tr>
<tr class="memdesc:a1ab7b5edf8e5831195940f8d377a6ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element via JSON Pointer with default value  <a href="classbasic__json.html#a1ab7b5edf8e5831195940f8d377a6ee3">More...</a><br /></td></tr>
<tr class="separator:a1ab7b5edf8e5831195940f8d377a6ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b67977cfd161b73161fa9341f8a4158"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3b67977cfd161b73161fa9341f8a4158"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3b67977cfd161b73161fa9341f8a4158">JSON_HEDLEY_DEPRECATED_FOR</a> (3.11.0, <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">basic_json::json_pointer</a> or nlohmann::json_pointer&lt; <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">basic_json::string_t</a> &gt;) ValueType <a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>(const</td></tr>
<tr class="memdesc:a3b67977cfd161b73161fa9341f8a4158"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the first element  <a href="classbasic__json.html#a3b67977cfd161b73161fa9341f8a4158">More...</a><br /></td></tr>
<tr class="separator:a3b67977cfd161b73161fa9341f8a4158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162089e94f24182ba3e4484be63c0c1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a162089e94f24182ba3e4484be63c0c1a">front</a> () const</td></tr>
<tr class="memdesc:a162089e94f24182ba3e4484be63c0c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the first element  <a href="classbasic__json.html#a162089e94f24182ba3e4484be63c0c1a">More...</a><br /></td></tr>
<tr class="separator:a162089e94f24182ba3e4484be63c0c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d93dc1dbdf67a6ee3a5cf1d2439ca77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0d93dc1dbdf67a6ee3a5cf1d2439ca77">back</a> ()</td></tr>
<tr class="memdesc:a0d93dc1dbdf67a6ee3a5cf1d2439ca77"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the last element  <a href="classbasic__json.html#a0d93dc1dbdf67a6ee3a5cf1d2439ca77">More...</a><br /></td></tr>
<tr class="separator:a0d93dc1dbdf67a6ee3a5cf1d2439ca77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41eee3066cd1ebfea746f9f07fd03f6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a41eee3066cd1ebfea746f9f07fd03f6f">back</a> () const</td></tr>
<tr class="memdesc:a41eee3066cd1ebfea746f9f07fd03f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the last element  <a href="classbasic__json.html#a41eee3066cd1ebfea746f9f07fd03f6f">More...</a><br /></td></tr>
<tr class="separator:a41eee3066cd1ebfea746f9f07fd03f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0fef086b1b72372113db6ce7446189"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , detail::enable_if_t&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;::value||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7d0fef086b1b72372113db6ce7446189"><td class="memTemplItemLeft" align="right" valign="top">IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7d0fef086b1b72372113db6ce7446189">erase</a> (IteratorType pos)</td></tr>
<tr class="memdesc:a7d0fef086b1b72372113db6ce7446189"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element given an iterator  <a href="classbasic__json.html#a7d0fef086b1b72372113db6ce7446189">More...</a><br /></td></tr>
<tr class="separator:a7d0fef086b1b72372113db6ce7446189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437b81c6e968a4192a22bc0de6c4df80"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , detail::enable_if_t&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;::value||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a437b81c6e968a4192a22bc0de6c4df80"><td class="memTemplItemLeft" align="right" valign="top">IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a437b81c6e968a4192a22bc0de6c4df80">erase</a> (IteratorType first, IteratorType last)</td></tr>
<tr class="memdesc:a437b81c6e968a4192a22bc0de6c4df80"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove elements given an iterator range  <a href="classbasic__json.html#a437b81c6e968a4192a22bc0de6c4df80">More...</a><br /></td></tr>
<tr class="separator:a437b81c6e968a4192a22bc0de6c4df80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05da3b93f2d4a7164589abffaa9acb33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a05da3b93f2d4a7164589abffaa9acb33">erase</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:a05da3b93f2d4a7164589abffaa9acb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element from a JSON object given a key  <a href="classbasic__json.html#a05da3b93f2d4a7164589abffaa9acb33">More...</a><br /></td></tr>
<tr class="separator:a05da3b93f2d4a7164589abffaa9acb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f763336e84232f38e2d80e142f9820e"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5f763336e84232f38e2d80e142f9820e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5f763336e84232f38e2d80e142f9820e">erase</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:a5f763336e84232f38e2d80e142f9820e"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element from a JSON object given a key  <a href="classbasic__json.html#a5f763336e84232f38e2d80e142f9820e">More...</a><br /></td></tr>
<tr class="separator:a5f763336e84232f38e2d80e142f9820e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c58b5f34c2ff56e27630214f5a9df4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac2c58b5f34c2ff56e27630214f5a9df4">erase</a> (const <a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> idx)</td></tr>
<tr class="memdesc:ac2c58b5f34c2ff56e27630214f5a9df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element from a JSON array given an index  <a href="classbasic__json.html#ac2c58b5f34c2ff56e27630214f5a9df4">More...</a><br /></td></tr>
<tr class="separator:ac2c58b5f34c2ff56e27630214f5a9df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">exceptions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp19ad27801b95bd1f2c6c2bf83dbb7515"></a>Classes to implement user-defined exceptions. </p>
</td></tr>
<tr class="memitem:a4ed57fa411e69ae5741bc2f333a967c9"><td class="memItemLeft" align="right" valign="top"><a id="a4ed57fa411e69ae5741bc2f333a967c9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>exception</b> = <a class="el" href="classdetail_1_1exception.html">detail::exception</a></td></tr>
<tr class="separator:a4ed57fa411e69ae5741bc2f333a967c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe1802a6a2de032f3c4e4f0f555ae10"><td class="memItemLeft" align="right" valign="top"><a id="a0fe1802a6a2de032f3c4e4f0f555ae10"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>parse_error</b> = <a class="el" href="classdetail_1_1parse__error.html">detail::parse_error</a></td></tr>
<tr class="separator:a0fe1802a6a2de032f3c4e4f0f555ae10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b69b2a91df080e00cc8f36c342bb6b"><td class="memItemLeft" align="right" valign="top"><a id="a34b69b2a91df080e00cc8f36c342bb6b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_iterator</b> = <a class="el" href="classdetail_1_1invalid__iterator.html">detail::invalid_iterator</a></td></tr>
<tr class="separator:a34b69b2a91df080e00cc8f36c342bb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c52f112e54d1be294055ea9186a1c35"><td class="memItemLeft" align="right" valign="top"><a id="a2c52f112e54d1be294055ea9186a1c35"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>type_error</b> = <a class="el" href="classdetail_1_1type__error.html">detail::type_error</a></td></tr>
<tr class="separator:a2c52f112e54d1be294055ea9186a1c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45e2d88a6cf9236c1f45a1fad18442d"><td class="memItemLeft" align="right" valign="top"><a id="aa45e2d88a6cf9236c1f45a1fad18442d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>out_of_range</b> = <a class="el" href="classdetail_1_1out__of__range.html">detail::out_of_range</a></td></tr>
<tr class="separator:aa45e2d88a6cf9236c1f45a1fad18442d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2d18607e0835c4695f53996b181379"><td class="memItemLeft" align="right" valign="top"><a id="adb2d18607e0835c4695f53996b181379"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>other_error</b> = <a class="el" href="classdetail_1_1other__error.html">detail::other_error</a></td></tr>
<tr class="separator:adb2d18607e0835c4695f53996b181379"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">container types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6618fa684bc6d5a05e2c88bfff1c0d66"></a>The canonic container types to use <a class="el" href="classbasic__json.html">basic_json</a> like any other STL container. </p>
</td></tr>
<tr class="memitem:a0d9e6a7acee2992e310ea21a7b59c67a"><td class="memItemLeft" align="right" valign="top"><a id="a0d9e6a7acee2992e310ea21a7b59c67a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0d9e6a7acee2992e310ea21a7b59c67a">value_type</a> = <a class="el" href="classbasic__json.html">basic_json</a></td></tr>
<tr class="memdesc:a0d9e6a7acee2992e310ea21a7b59c67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of elements in a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container <br /></td></tr>
<tr class="separator:a0d9e6a7acee2992e310ea21a7b59c67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca7bfb35987ce7cb8d27447cda5b80a"><td class="memItemLeft" align="right" valign="top"><a id="a6ca7bfb35987ce7cb8d27447cda5b80a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> = <a class="el" href="classbasic__json.html#a0d9e6a7acee2992e310ea21a7b59c67a">value_type</a> &amp;</td></tr>
<tr class="memdesc:a6ca7bfb35987ce7cb8d27447cda5b80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element reference <br /></td></tr>
<tr class="separator:a6ca7bfb35987ce7cb8d27447cda5b80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31370bb451b78198d42c86dd31955deb"><td class="memItemLeft" align="right" valign="top"><a id="a31370bb451b78198d42c86dd31955deb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> = const <a class="el" href="classbasic__json.html#a0d9e6a7acee2992e310ea21a7b59c67a">value_type</a> &amp;</td></tr>
<tr class="memdesc:a31370bb451b78198d42c86dd31955deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element const reference <br /></td></tr>
<tr class="separator:a31370bb451b78198d42c86dd31955deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45e8f7ce7c3e62035cd097a39910399"><td class="memItemLeft" align="right" valign="top"><a id="ae45e8f7ce7c3e62035cd097a39910399"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae45e8f7ce7c3e62035cd097a39910399">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:ae45e8f7ce7c3e62035cd097a39910399"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type to represent differences between iterators <br /></td></tr>
<tr class="separator:ae45e8f7ce7c3e62035cd097a39910399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c086af43cf06b1b7118f5351cab3ec9"><td class="memItemLeft" align="right" valign="top"><a id="a2c086af43cf06b1b7118f5351cab3ec9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a2c086af43cf06b1b7118f5351cab3ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type to represent container sizes <br /></td></tr>
<tr class="separator:a2c086af43cf06b1b7118f5351cab3ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f845db2d54cedad97279bad70aea52"><td class="memItemLeft" align="right" valign="top"><a id="a83f845db2d54cedad97279bad70aea52"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a83f845db2d54cedad97279bad70aea52">allocator_type</a> = AllocatorType&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a83f845db2d54cedad97279bad70aea52"><td class="mdescLeft">&#160;</td><td class="mdescRight">the allocator type <br /></td></tr>
<tr class="separator:a83f845db2d54cedad97279bad70aea52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84279673ab13fb6360cf17173a29a1f1"><td class="memItemLeft" align="right" valign="top"><a id="a84279673ab13fb6360cf17173a29a1f1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a84279673ab13fb6360cf17173a29a1f1">pointer</a> = typename std::allocator_traits&lt; <a class="el" href="classbasic__json.html#a83f845db2d54cedad97279bad70aea52">allocator_type</a> &gt;::<a class="el" href="classbasic__json.html#a84279673ab13fb6360cf17173a29a1f1">pointer</a></td></tr>
<tr class="memdesc:a84279673ab13fb6360cf17173a29a1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element pointer <br /></td></tr>
<tr class="separator:a84279673ab13fb6360cf17173a29a1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2862fa42527f5c14d9f737411e0facd4"><td class="memItemLeft" align="right" valign="top"><a id="a2862fa42527f5c14d9f737411e0facd4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2862fa42527f5c14d9f737411e0facd4">const_pointer</a> = typename std::allocator_traits&lt; <a class="el" href="classbasic__json.html#a83f845db2d54cedad97279bad70aea52">allocator_type</a> &gt;::<a class="el" href="classbasic__json.html#a2862fa42527f5c14d9f737411e0facd4">const_pointer</a></td></tr>
<tr class="memdesc:a2862fa42527f5c14d9f737411e0facd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element const pointer <br /></td></tr>
<tr class="separator:a2862fa42527f5c14d9f737411e0facd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae206a491161d043f8efaa1330f1ccf97"><td class="memItemLeft" align="right" valign="top"><a id="ae206a491161d043f8efaa1330f1ccf97"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> = iter_impl&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:ae206a491161d043f8efaa1330f1ccf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">an iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container <br /></td></tr>
<tr class="separator:ae206a491161d043f8efaa1330f1ccf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5af3d9d06d43b91fefe1767794b1e8"><td class="memItemLeft" align="right" valign="top"><a id="a1f5af3d9d06d43b91fefe1767794b1e8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> = iter_impl&lt; const <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a1f5af3d9d06d43b91fefe1767794b1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">a const iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container <br /></td></tr>
<tr class="separator:a1f5af3d9d06d43b91fefe1767794b1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc059cdae078322bb0d434b2127d1cf"><td class="memItemLeft" align="right" valign="top"><a id="aedc059cdae078322bb0d434b2127d1cf"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aedc059cdae078322bb0d434b2127d1cf">reverse_iterator</a> = json_reverse_iterator&lt; typename <a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">basic_json::iterator</a> &gt;</td></tr>
<tr class="memdesc:aedc059cdae078322bb0d434b2127d1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">a reverse iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container <br /></td></tr>
<tr class="separator:aedc059cdae078322bb0d434b2127d1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240f61567d8acffe831532f4f9b379cb"><td class="memItemLeft" align="right" valign="top"><a id="a240f61567d8acffe831532f4f9b379cb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a240f61567d8acffe831532f4f9b379cb">const_reverse_iterator</a> = json_reverse_iterator&lt; typename <a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">basic_json::const_iterator</a> &gt;</td></tr>
<tr class="memdesc:a240f61567d8acffe831532f4f9b379cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">a const reverse iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container <br /></td></tr>
<tr class="separator:a240f61567d8acffe831532f4f9b379cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON value data types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbddfba6d49869d59bfd397e65b8cba87"></a>The data types to store a JSON value. These types are derived from the template arguments passed to class <a class="el" href="classbasic__json.html">basic_json</a>. </p>
</td></tr>
<tr class="memitem:a991d005e7f648cbf37bb36daf85183ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a991d005e7f648cbf37bb36daf85183ca">default_object_comparator_t</a> = std::less&lt; StringType &gt;</td></tr>
<tr class="memdesc:a991d005e7f648cbf37bb36daf85183ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">default object key comparator type The actual object key comparator type (<a class="el" href="classbasic__json.html#af12040e0663db54840d73d363979643a">object_comparator_t</a>) may be different.  <a href="classbasic__json.html#a991d005e7f648cbf37bb36daf85183ca">More...</a><br /></td></tr>
<tr class="separator:a991d005e7f648cbf37bb36daf85183ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90f70623dc1ad761ea1c5013b2fee47"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> = ObjectType&lt; StringType, <a class="el" href="classbasic__json.html">basic_json</a>, <a class="el" href="classbasic__json.html#a991d005e7f648cbf37bb36daf85183ca">default_object_comparator_t</a>, AllocatorType&lt; std::pair&lt; const StringType, <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ac90f70623dc1ad761ea1c5013b2fee47"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for an object  <a href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">More...</a><br /></td></tr>
<tr class="separator:ac90f70623dc1ad761ea1c5013b2fee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b282cae56b331d222c7da4b05eab5e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> = ArrayType&lt; <a class="el" href="classbasic__json.html">basic_json</a>, AllocatorType&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt;</td></tr>
<tr class="memdesc:a6b282cae56b331d222c7da4b05eab5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for an array  <a href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">More...</a><br /></td></tr>
<tr class="separator:a6b282cae56b331d222c7da4b05eab5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c9cde32146e6c343e1960aefc11fba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> = StringType</td></tr>
<tr class="memdesc:ac8c9cde32146e6c343e1960aefc11fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a string  <a href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">More...</a><br /></td></tr>
<tr class="separator:ac8c9cde32146e6c343e1960aefc11fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9301890c48e9b957edc07f9eb767bd10"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> = BooleanType</td></tr>
<tr class="memdesc:a9301890c48e9b957edc07f9eb767bd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a boolean  <a href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">More...</a><br /></td></tr>
<tr class="separator:a9301890c48e9b957edc07f9eb767bd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba48b0bdee31228a4e19b7c040b6d2a5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a> = NumberIntegerType</td></tr>
<tr class="memdesc:aba48b0bdee31228a4e19b7c040b6d2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (integer)  <a href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">More...</a><br /></td></tr>
<tr class="separator:aba48b0bdee31228a4e19b7c040b6d2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8505b599e706768a1e0bd6718cc7117"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a> = NumberUnsignedType</td></tr>
<tr class="memdesc:ae8505b599e706768a1e0bd6718cc7117"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (unsigned)  <a href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">More...</a><br /></td></tr>
<tr class="separator:ae8505b599e706768a1e0bd6718cc7117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a229dbc84c1334171ce9c49c873c56"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a> = NumberFloatType</td></tr>
<tr class="memdesc:a80a229dbc84c1334171ce9c49c873c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (floating-point)  <a href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">More...</a><br /></td></tr>
<tr class="separator:a80a229dbc84c1334171ce9c49c873c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1b5ea434b48cf31097617bb1c1ca1e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> = nlohmann::byte_container_with_subtype&lt; BinaryType &gt;</td></tr>
<tr class="memdesc:a4c1b5ea434b48cf31097617bb1c1ca1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a packed binary type  <a href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">More...</a><br /></td></tr>
<tr class="separator:a4c1b5ea434b48cf31097617bb1c1ca1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12040e0663db54840d73d363979643a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af12040e0663db54840d73d363979643a">object_comparator_t</a> = detail::actual_object_comparator_t&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:af12040e0663db54840d73d363979643a"><td class="mdescLeft">&#160;</td><td class="mdescRight">object key comparator type  <a href="classbasic__json.html#af12040e0663db54840d73d363979643a">More...</a><br /></td></tr>
<tr class="separator:af12040e0663db54840d73d363979643a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">modifiers</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbf24b44a8cc99e648657b164c8aba758"></a>checks whether the container is empty.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/empty/">https://json.nlohmann.me/api/basic_json/empty/</a></dd></dl>
<p>returns the number of elements </p><dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/size/">https://json.nlohmann.me/api/basic_json/size/</a></dd></dl>
<p>returns the maximum possible number of elements </p><dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/max_size/">https://json.nlohmann.me/api/basic_json/max_size/</a> </dd></dl>
</td></tr>
<tr class="memitem:a44c98b48b8a0b5e53087776fbb63961f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a44c98b48b8a0b5e53087776fbb63961f">swap</a> (<a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> left, <a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> right) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; json_value &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;//NOLINT(cppcoreguidelines-noexcept-swap, performance-noexcept-swap) std::is_nothrow_move_assignable&lt; json_value &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:a44c98b48b8a0b5e53087776fbb63961f"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="classbasic__json.html#a44c98b48b8a0b5e53087776fbb63961f">More...</a><br /></td></tr>
<tr class="separator:a44c98b48b8a0b5e53087776fbb63961f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac444a656905e3f207ad9fc19275faf25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac444a656905e3f207ad9fc19275faf25">operator+=</a> (<a class="el" href="classbasic__json.html">basic_json</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:ac444a656905e3f207ad9fc19275faf25"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classbasic__json.html#ac444a656905e3f207ad9fc19275faf25">More...</a><br /></td></tr>
<tr class="separator:ac444a656905e3f207ad9fc19275faf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca01ca3a9bc310e5c5d067a39dca6933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aca01ca3a9bc310e5c5d067a39dca6933">push_back</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:aca01ca3a9bc310e5c5d067a39dca6933"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classbasic__json.html#aca01ca3a9bc310e5c5d067a39dca6933">More...</a><br /></td></tr>
<tr class="separator:aca01ca3a9bc310e5c5d067a39dca6933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4475e951f51506808ca6fe7e77eb38ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4475e951f51506808ca6fe7e77eb38ca">operator+=</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a4475e951f51506808ca6fe7e77eb38ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classbasic__json.html#a4475e951f51506808ca6fe7e77eb38ca">More...</a><br /></td></tr>
<tr class="separator:a4475e951f51506808ca6fe7e77eb38ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17fe93acad9b0b991600225dabd42be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af17fe93acad9b0b991600225dabd42be">push_back</a> (const typename object_t::value_type &amp;val)</td></tr>
<tr class="memdesc:af17fe93acad9b0b991600225dabd42be"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <a href="classbasic__json.html#af17fe93acad9b0b991600225dabd42be">More...</a><br /></td></tr>
<tr class="separator:af17fe93acad9b0b991600225dabd42be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996a58d60e4badd9beadfd3e2e7ffdc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a996a58d60e4badd9beadfd3e2e7ffdc1">operator+=</a> (const typename object_t::value_type &amp;val)</td></tr>
<tr class="memdesc:a996a58d60e4badd9beadfd3e2e7ffdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <a href="classbasic__json.html#a996a58d60e4badd9beadfd3e2e7ffdc1">More...</a><br /></td></tr>
<tr class="separator:a996a58d60e4badd9beadfd3e2e7ffdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcacc90f17b156f0b6c8e0430624853"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4fcacc90f17b156f0b6c8e0430624853">push_back</a> (<a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> init)</td></tr>
<tr class="memdesc:a4fcacc90f17b156f0b6c8e0430624853"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <a href="classbasic__json.html#a4fcacc90f17b156f0b6c8e0430624853">More...</a><br /></td></tr>
<tr class="separator:a4fcacc90f17b156f0b6c8e0430624853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af74b651da5642cd8b77a3ecc635331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3af74b651da5642cd8b77a3ecc635331">operator+=</a> (<a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> init)</td></tr>
<tr class="memdesc:a3af74b651da5642cd8b77a3ecc635331"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <a href="classbasic__json.html#a3af74b651da5642cd8b77a3ecc635331">More...</a><br /></td></tr>
<tr class="separator:a3af74b651da5642cd8b77a3ecc635331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f0a15957842b188826aea98a9cfd3d"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ac5f0a15957842b188826aea98a9cfd3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac5f0a15957842b188826aea98a9cfd3d">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac5f0a15957842b188826aea98a9cfd3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <a href="classbasic__json.html#ac5f0a15957842b188826aea98a9cfd3d">More...</a><br /></td></tr>
<tr class="separator:ac5f0a15957842b188826aea98a9cfd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac366495e80b2f51a09f07471006cde28"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ac366495e80b2f51a09f07471006cde28"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac366495e80b2f51a09f07471006cde28">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac366495e80b2f51a09f07471006cde28"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object if key does not exist  <a href="classbasic__json.html#ac366495e80b2f51a09f07471006cde28">More...</a><br /></td></tr>
<tr class="separator:ac366495e80b2f51a09f07471006cde28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c5ca19d22a32054452470669c43bb9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:af8c5ca19d22a32054452470669c43bb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af8c5ca19d22a32054452470669c43bb9">insert_iterator</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:af8c5ca19d22a32054452470669c43bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3817060c2bec896a99cb2c236b9c27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7f3817060c2bec896a99cb2c236b9c27">insert</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> pos, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a7f3817060c2bec896a99cb2c236b9c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts element into array  <a href="classbasic__json.html#a7f3817060c2bec896a99cb2c236b9c27">More...</a><br /></td></tr>
<tr class="separator:a7f3817060c2bec896a99cb2c236b9c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5da62116a40a0f86e87f11fdd54e9f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae5da62116a40a0f86e87f11fdd54e9f0">insert</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> pos, <a class="el" href="classbasic__json.html">basic_json</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:ae5da62116a40a0f86e87f11fdd54e9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts element into array  <a href="classbasic__json.html#ae5da62116a40a0f86e87f11fdd54e9f0">More...</a><br /></td></tr>
<tr class="separator:ae5da62116a40a0f86e87f11fdd54e9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b623200562da188886a385c716d101"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a47b623200562da188886a385c716d101">insert</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> pos, <a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> cnt, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a47b623200562da188886a385c716d101"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts copies of element into array  <a href="classbasic__json.html#a47b623200562da188886a385c716d101">More...</a><br /></td></tr>
<tr class="separator:a47b623200562da188886a385c716d101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e1707248a00a2608a304da5ae5c911"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a68e1707248a00a2608a304da5ae5c911">insert</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> pos, <a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> first, <a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> last)</td></tr>
<tr class="memdesc:a68e1707248a00a2608a304da5ae5c911"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts range of elements into array  <a href="classbasic__json.html#a68e1707248a00a2608a304da5ae5c911">More...</a><br /></td></tr>
<tr class="separator:a68e1707248a00a2608a304da5ae5c911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfee6a3db80431a24c68bfaf038c47d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abdfee6a3db80431a24c68bfaf038c47d">insert</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> pos, <a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> ilist)</td></tr>
<tr class="memdesc:abdfee6a3db80431a24c68bfaf038c47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts elements from initializer list into array  <a href="classbasic__json.html#abdfee6a3db80431a24c68bfaf038c47d">More...</a><br /></td></tr>
<tr class="separator:abdfee6a3db80431a24c68bfaf038c47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf55c485c75ddd7bd5f9791e59d3aec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aaf55c485c75ddd7bd5f9791e59d3aec7">insert</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> first, <a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> last)</td></tr>
<tr class="memdesc:aaf55c485c75ddd7bd5f9791e59d3aec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts range of elements into object  <a href="classbasic__json.html#aaf55c485c75ddd7bd5f9791e59d3aec7">More...</a><br /></td></tr>
<tr class="separator:aaf55c485c75ddd7bd5f9791e59d3aec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3819f393e82396782ccc22785575b01d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3819f393e82396782ccc22785575b01d">update</a> (<a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> j, bool merge_objects=false)</td></tr>
<tr class="memdesc:a3819f393e82396782ccc22785575b01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a JSON object from another object, overwriting existing keys  <a href="classbasic__json.html#a3819f393e82396782ccc22785575b01d">More...</a><br /></td></tr>
<tr class="separator:a3819f393e82396782ccc22785575b01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea2b8cef5e4aba5b92d14e6ebe25936"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4ea2b8cef5e4aba5b92d14e6ebe25936">update</a> (<a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> first, <a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> last, bool merge_objects=false)</td></tr>
<tr class="memdesc:a4ea2b8cef5e4aba5b92d14e6ebe25936"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a JSON object from another object, overwriting existing keys  <a href="classbasic__json.html#a4ea2b8cef5e4aba5b92d14e6ebe25936">More...</a><br /></td></tr>
<tr class="separator:a4ea2b8cef5e4aba5b92d14e6ebe25936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a94e5348ebb34852092d51a44e21d24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1a94e5348ebb34852092d51a44e21d24">swap</a> (<a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> other) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; json_value &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;//NOLINT(cppcoreguidelines-noexcept-swap, performance-noexcept-swap) std::is_nothrow_move_assignable&lt; json_value &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:a1a94e5348ebb34852092d51a44e21d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="classbasic__json.html#a1a94e5348ebb34852092d51a44e21d24">More...</a><br /></td></tr>
<tr class="separator:a1a94e5348ebb34852092d51a44e21d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e32c91d5e641c25c52486341f5a9db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac1e32c91d5e641c25c52486341f5a9db">swap</a> (<a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> &amp;other)</td></tr>
<tr class="memdesc:ac1e32c91d5e641c25c52486341f5a9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="classbasic__json.html#ac1e32c91d5e641c25c52486341f5a9db">More...</a><br /></td></tr>
<tr class="separator:ac1e32c91d5e641c25c52486341f5a9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9ea6dec87e254de172c2bfeaeef7df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abc9ea6dec87e254de172c2bfeaeef7df">swap</a> (<a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> &amp;other)</td></tr>
<tr class="memdesc:abc9ea6dec87e254de172c2bfeaeef7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="classbasic__json.html#abc9ea6dec87e254de172c2bfeaeef7df">More...</a><br /></td></tr>
<tr class="separator:abc9ea6dec87e254de172c2bfeaeef7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac8816c033c659ef8b43a5f03d5f553"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aeac8816c033c659ef8b43a5f03d5f553">swap</a> (<a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> &amp;other)</td></tr>
<tr class="memdesc:aeac8816c033c659ef8b43a5f03d5f553"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="classbasic__json.html#aeac8816c033c659ef8b43a5f03d5f553">More...</a><br /></td></tr>
<tr class="separator:aeac8816c033c659ef8b43a5f03d5f553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3624e1bbc880bd196e3fa4a220554755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3624e1bbc880bd196e3fa4a220554755">swap</a> (<a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> &amp;other)</td></tr>
<tr class="memdesc:a3624e1bbc880bd196e3fa4a220554755"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="classbasic__json.html#a3624e1bbc880bd196e3fa4a220554755">More...</a><br /></td></tr>
<tr class="separator:a3624e1bbc880bd196e3fa4a220554755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa987625005046c81e7748dca1e84a0e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa987625005046c81e7748dca1e84a0e3">swap</a> (typename binary_t::container_type &amp;other)</td></tr>
<tr class="memdesc:aa987625005046c81e7748dca1e84a0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <a href="classbasic__json.html#aa987625005046c81e7748dca1e84a0e3">More...</a><br /></td></tr>
<tr class="separator:aa987625005046c81e7748dca1e84a0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">lexicographical comparison operators</h2></td></tr>
<tr class="memitem:a7dd56e6dab5328365a3c9b9d15f98e1b"><td class="memItemLeft" align="right" valign="top"><a id="a7dd56e6dab5328365a3c9b9d15f98e1b"></a>
JSON_PRIVATE_UNLESS_TESTED&#160;</td><td class="memItemRight" valign="bottom"><b>__pad3__</b>: static bool compares_unordered(<a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> lhs</td></tr>
<tr class="separator:a7dd56e6dab5328365a3c9b9d15f98e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a549b97cc690cd390145249335d3768"><td class="memItemLeft" align="right" valign="top"><a id="a3a549b97cc690cd390145249335d3768"></a>
JSON_PRIVATE_UNLESS_TESTED <a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rhs</b></td></tr>
<tr class="separator:a3a549b97cc690cd390145249335d3768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54aba2f4314135e3ccf511fb17ca45a5"><td class="memItemLeft" align="right" valign="top"><a id="a54aba2f4314135e3ccf511fb17ca45a5"></a>
JSON_PRIVATE_UNLESS_TESTED <a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>inverse</b></td></tr>
<tr class="separator:a54aba2f4314135e3ccf511fb17ca45a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">value access</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd8f53c9caf18314e5b3f758245606995"></a>Direct access to the stored value of a JSON value. </p>
</td></tr>
<tr class="memitem:aba60354728e2f7f64e3e5c6b02c5b820"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:aba60354728e2f7f64e3e5c6b02c5b820"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aba60354728e2f7f64e3e5c6b02c5b820">get_ptr</a> () noexcept -&gt; decltype(std::declval&lt; basic_json_t &amp; &gt;().get_impl_ptr(std::declval&lt; PointerType &gt;()))</td></tr>
<tr class="memdesc:aba60354728e2f7f64e3e5c6b02c5b820"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (implicit)  <a href="classbasic__json.html#aba60354728e2f7f64e3e5c6b02c5b820">More...</a><br /></td></tr>
<tr class="separator:aba60354728e2f7f64e3e5c6b02c5b820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db8d5e59277a70a736f899c4aec0af0"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value &amp;&amp;std::is_const&lt; typename std::remove_pointer&lt; PointerType &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a9db8d5e59277a70a736f899c4aec0af0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9db8d5e59277a70a736f899c4aec0af0">get_ptr</a> () const noexcept -&gt; decltype(std::declval&lt; const basic_json_t &amp; &gt;().get_impl_ptr(std::declval&lt; PointerType &gt;()))</td></tr>
<tr class="memdesc:a9db8d5e59277a70a736f899c4aec0af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (implicit)  <a href="classbasic__json.html#a9db8d5e59277a70a736f899c4aec0af0">More...</a><br /></td></tr>
<tr class="separator:a9db8d5e59277a70a736f899c4aec0af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab31c7fdbab38898070bca01637f886"><td class="memTemplParams" colspan="2">template&lt;typename ValueTypeCV , typename ValueType  = detail::uncvref_t&lt;ValueTypeCV&gt;&gt; </td></tr>
<tr class="memitem:a0ab31c7fdbab38898070bca01637f886"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0ab31c7fdbab38898070bca01637f886">get</a> () const noexcept(noexcept(std::declval&lt; const basic_json_t &amp; &gt;().template get_impl&lt; ValueType &gt;(<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 4 &gt; {}))) -&gt; decltype(std::declval&lt; const basic_json_t &amp; &gt;().template get_impl&lt; ValueType &gt;(<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 4 &gt; {}))</td></tr>
<tr class="memdesc:a0ab31c7fdbab38898070bca01637f886"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a (pointer) value (explicit)  <a href="classbasic__json.html#a0ab31c7fdbab38898070bca01637f886">More...</a><br /></td></tr>
<tr class="separator:a0ab31c7fdbab38898070bca01637f886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11f66d4edc50a209fab3f8c48664a53"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab11f66d4edc50a209fab3f8c48664a53"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab11f66d4edc50a209fab3f8c48664a53">get</a> () noexcept -&gt; decltype(std::declval&lt; basic_json_t &amp; &gt;().template <a class="el" href="classbasic__json.html#aba60354728e2f7f64e3e5c6b02c5b820">get_ptr</a>&lt; PointerType &gt;())</td></tr>
<tr class="memdesc:ab11f66d4edc50a209fab3f8c48664a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (explicit)  <a href="classbasic__json.html#ab11f66d4edc50a209fab3f8c48664a53">More...</a><br /></td></tr>
<tr class="separator:ab11f66d4edc50a209fab3f8c48664a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055a78a155eef5fbf05d40899cc7eff9"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , detail::enable_if_t&lt; !detail::is_basic_json&lt; ValueType &gt;::value &amp;&amp;detail::has_from_json&lt; basic_json_t, ValueType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a055a78a155eef5fbf05d40899cc7eff9"><td class="memTemplItemLeft" align="right" valign="top">ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a055a78a155eef5fbf05d40899cc7eff9">get_to</a> (ValueType &amp;v) const noexcept(noexcept(JSONSerializer&lt; ValueType &gt;::from_json(std::declval&lt; const basic_json_t &amp; &gt;(), v)))</td></tr>
<tr class="memdesc:a055a78a155eef5fbf05d40899cc7eff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a value (explicit)  <a href="classbasic__json.html#a055a78a155eef5fbf05d40899cc7eff9">More...</a><br /></td></tr>
<tr class="separator:a055a78a155eef5fbf05d40899cc7eff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b5d8cbbde2eb425b55690024b1a5a1"><td class="memTemplParams" colspan="2"><a id="a81b5d8cbbde2eb425b55690024b1a5a1"></a>
template&lt;typename ValueType , detail::enable_if_t&lt; detail::is_basic_json&lt; ValueType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a81b5d8cbbde2eb425b55690024b1a5a1"><td class="memTemplItemLeft" align="right" valign="top">ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_to</b> (ValueType &amp;v) const</td></tr>
<tr class="separator:a81b5d8cbbde2eb425b55690024b1a5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ffeca3b8431bbc7bab0280f843f79e"><td class="memTemplParams" colspan="2"><a id="ab8ffeca3b8431bbc7bab0280f843f79e"></a>
template&lt;typename T , std::size_t N, typename Array  = T (&amp;)[N], detail::enable_if_t&lt; detail::has_from_json&lt; basic_json_t, Array &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab8ffeca3b8431bbc7bab0280f843f79e"><td class="memTemplItemLeft" align="right" valign="top">Array&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_to</b> (T(&amp;v)[N]) const noexcept(noexcept(JSONSerializer&lt; Array &gt;::from_json(std::declval&lt; const basic_json_t &amp; &gt;(), v)))</td></tr>
<tr class="separator:ab8ffeca3b8431bbc7bab0280f843f79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3697078e748abc4a99c23e36e321b439"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a3697078e748abc4a99c23e36e321b439"><td class="memTemplItemLeft" align="right" valign="top">ReferenceType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3697078e748abc4a99c23e36e321b439">get_ref</a> ()</td></tr>
<tr class="memdesc:a3697078e748abc4a99c23e36e321b439"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reference value (implicit)  <a href="classbasic__json.html#a3697078e748abc4a99c23e36e321b439">More...</a><br /></td></tr>
<tr class="separator:a3697078e748abc4a99c23e36e321b439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c5dbafcc6eef79143c251096827549"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;::value &amp;&amp;std::is_const&lt; typename std::remove_reference&lt; ReferenceType &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a39c5dbafcc6eef79143c251096827549"><td class="memTemplItemLeft" align="right" valign="top">ReferenceType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a39c5dbafcc6eef79143c251096827549">get_ref</a> () const</td></tr>
<tr class="memdesc:a39c5dbafcc6eef79143c251096827549"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reference value (implicit)  <a href="classbasic__json.html#a39c5dbafcc6eef79143c251096827549">More...</a><br /></td></tr>
<tr class="separator:a39c5dbafcc6eef79143c251096827549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747e3e19891143442991bbdb33edb917"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename std::enable_if&lt; detail::conjunction&lt; detail::negation&lt; std::is_pointer&lt; ValueType &gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, std::nullptr_t &gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, detail::json_ref&lt; basic_json &gt;&gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, typename string_t::value_type &gt;&gt;, detail::negation&lt; detail::is_basic_json&lt; ValueType &gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, std::initializer_list&lt; typename string_t::value_type &gt;&gt;&gt;, detail::is_detected_lazy&lt; detail::get_template_function, const basic_json_t &amp;, ValueType &gt; &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a747e3e19891143442991bbdb33edb917"><td class="memTemplItemLeft" align="right" valign="top">JSON_EXPLICIT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a747e3e19891143442991bbdb33edb917">operator ValueType</a> () const</td></tr>
<tr class="memdesc:a747e3e19891143442991bbdb33edb917"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a value (implicit)  <a href="classbasic__json.html#a747e3e19891143442991bbdb33edb917">More...</a><br /></td></tr>
<tr class="separator:a747e3e19891143442991bbdb33edb917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55de1b3601085c32e4a1dc32ef6d32d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac55de1b3601085c32e4a1dc32ef6d32d">get_binary</a> ()</td></tr>
<tr class="memdesc:ac55de1b3601085c32e4a1dc32ef6d32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a binary value  <a href="classbasic__json.html#ac55de1b3601085c32e4a1dc32ef6d32d">More...</a><br /></td></tr>
<tr class="separator:ac55de1b3601085c32e4a1dc32ef6d32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab13e0430cfea76c05ccd062aa528ec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4ab13e0430cfea76c05ccd062aa528ec">get_binary</a> () const</td></tr>
<tr class="memdesc:a4ab13e0430cfea76c05ccd062aa528ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a binary value  <a href="classbasic__json.html#a4ab13e0430cfea76c05ccd062aa528ec">More...</a><br /></td></tr>
<tr class="separator:a4ab13e0430cfea76c05ccd062aa528ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">constructors and destructors</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd94b4d3d0135946bb7bdf25e48755337"></a>Constructors of class <a class="el" href="classbasic__json.html">basic_json</a>, copy/move constructor, copy assignment, static functions creating objects, and the destructor. </p>
</td></tr>
<tr class="memitem:a743ac3bcbc4b0f7897244d4cea387eee"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a743ac3bcbc4b0f7897244d4cea387eee">binary</a> (const typename binary_t::container_type &amp;init)</td></tr>
<tr class="memdesc:a743ac3bcbc4b0f7897244d4cea387eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <a href="classbasic__json.html#a743ac3bcbc4b0f7897244d4cea387eee">More...</a><br /></td></tr>
<tr class="separator:a743ac3bcbc4b0f7897244d4cea387eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e65e73d9ecf780537d632372fa2c51"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a45e65e73d9ecf780537d632372fa2c51">binary</a> (const typename binary_t::container_type &amp;init, typename binary_t::subtype_type subtype)</td></tr>
<tr class="memdesc:a45e65e73d9ecf780537d632372fa2c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (with subtype)  <a href="classbasic__json.html#a45e65e73d9ecf780537d632372fa2c51">More...</a><br /></td></tr>
<tr class="separator:a45e65e73d9ecf780537d632372fa2c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af2196a9acde33f742ef054e7c2109c"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5af2196a9acde33f742ef054e7c2109c">binary</a> (typename binary_t::container_type &amp;&amp;init)</td></tr>
<tr class="memdesc:a5af2196a9acde33f742ef054e7c2109c"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array  <a href="classbasic__json.html#a5af2196a9acde33f742ef054e7c2109c">More...</a><br /></td></tr>
<tr class="separator:a5af2196a9acde33f742ef054e7c2109c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00a2a38929ce21eae65f9dd09b03ce3"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac00a2a38929ce21eae65f9dd09b03ce3">binary</a> (typename binary_t::container_type &amp;&amp;init, typename binary_t::subtype_type subtype)</td></tr>
<tr class="memdesc:ac00a2a38929ce21eae65f9dd09b03ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (with subtype)  <a href="classbasic__json.html#ac00a2a38929ce21eae65f9dd09b03ce3">More...</a><br /></td></tr>
<tr class="separator:ac00a2a38929ce21eae65f9dd09b03ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac736994a792cb8460a30a3f4dd86fd78"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac736994a792cb8460a30a3f4dd86fd78">array</a> (<a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> init={})</td></tr>
<tr class="memdesc:ac736994a792cb8460a30a3f4dd86fd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create an array from an initializer list  <a href="classbasic__json.html#ac736994a792cb8460a30a3f4dd86fd78">More...</a><br /></td></tr>
<tr class="separator:ac736994a792cb8460a30a3f4dd86fd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a0e8dacc0f4aa12162da666595e6fd"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a50a0e8dacc0f4aa12162da666595e6fd">object</a> (<a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> init={})</td></tr>
<tr class="memdesc:a50a0e8dacc0f4aa12162da666595e6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create an object from an initializer list  <a href="classbasic__json.html#a50a0e8dacc0f4aa12162da666595e6fd">More...</a><br /></td></tr>
<tr class="separator:a50a0e8dacc0f4aa12162da666595e6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d5bc42270881ed3e219e8b1456fec5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae2d5bc42270881ed3e219e8b1456fec5">basic_json</a> (const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> v)</td></tr>
<tr class="memdesc:ae2d5bc42270881ed3e219e8b1456fec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an empty value with a given type  <a href="classbasic__json.html#ae2d5bc42270881ed3e219e8b1456fec5">More...</a><br /></td></tr>
<tr class="separator:ae2d5bc42270881ed3e219e8b1456fec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1fab9ded0a2a182837bd66c0e5189e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5b1fab9ded0a2a182837bd66c0e5189e">basic_json</a> (std::nullptr_t=nullptr) noexcept</td></tr>
<tr class="memdesc:a5b1fab9ded0a2a182837bd66c0e5189e"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a null object  <a href="classbasic__json.html#a5b1fab9ded0a2a182837bd66c0e5189e">More...</a><br /></td></tr>
<tr class="separator:a5b1fab9ded0a2a182837bd66c0e5189e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f24e66b152203259eaf05c33ebaeed4"><td class="memTemplParams" colspan="2">template&lt;typename CompatibleType , typename U  = detail::uncvref_t&lt;CompatibleType&gt;, detail::enable_if_t&lt; !detail::is_basic_json&lt; U &gt;::value &amp;&amp;detail::is_compatible_type&lt; basic_json_t, U &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0f24e66b152203259eaf05c33ebaeed4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0f24e66b152203259eaf05c33ebaeed4">basic_json</a> (CompatibleType &amp;&amp;val) noexcept(noexcept(//NOLINT(bugprone-forwarding-<a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>-overload, bugprone-<a class="el" href="classdetail_1_1exception.html">exception</a>-escape) JSONSerializer&lt; U &gt;::to_json(std::declval&lt; basic_json_t &amp; &gt;(), std::forward&lt; CompatibleType &gt;(val))))</td></tr>
<tr class="memdesc:a0f24e66b152203259eaf05c33ebaeed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from compatible types  <a href="classbasic__json.html#a0f24e66b152203259eaf05c33ebaeed4">More...</a><br /></td></tr>
<tr class="separator:a0f24e66b152203259eaf05c33ebaeed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf10402e79a1acce9a74f5a9654d403"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value &amp;&amp;!std::is_same&lt; basic_json, BasicJsonType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aeaf10402e79a1acce9a74f5a9654d403"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aeaf10402e79a1acce9a74f5a9654d403">basic_json</a> (const BasicJsonType &amp;val)</td></tr>
<tr class="memdesc:aeaf10402e79a1acce9a74f5a9654d403"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an existing one  <a href="classbasic__json.html#aeaf10402e79a1acce9a74f5a9654d403">More...</a><br /></td></tr>
<tr class="separator:aeaf10402e79a1acce9a74f5a9654d403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa911d47d3c99184a301bf4fd304199b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa911d47d3c99184a301bf4fd304199b2">basic_json</a> (<a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a> init, bool type_deduction=true, <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> manual_type=<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a>)</td></tr>
<tr class="memdesc:aa911d47d3c99184a301bf4fd304199b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a container (array or object) from an initializer list  <a href="classbasic__json.html#aa911d47d3c99184a301bf4fd304199b2">More...</a><br /></td></tr>
<tr class="separator:aa911d47d3c99184a301bf4fd304199b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6f0605b09a002567fd18a289cef31b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7b6f0605b09a002567fd18a289cef31b">basic_json</a> (<a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> cnt, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a7b6f0605b09a002567fd18a289cef31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct an array with count copies of given value  <a href="classbasic__json.html#a7b6f0605b09a002567fd18a289cef31b">More...</a><br /></td></tr>
<tr class="separator:a7b6f0605b09a002567fd18a289cef31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97b4fcd01509076c8a7b32ec1a10aec"><td class="memTemplParams" colspan="2">template&lt;class InputIT , typename std::enable_if&lt; std::is_same&lt; InputIT, typename basic_json_t::iterator &gt;::value||std::is_same&lt; InputIT, typename basic_json_t::const_iterator &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:af97b4fcd01509076c8a7b32ec1a10aec"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af97b4fcd01509076c8a7b32ec1a10aec">basic_json</a> (InputIT first, InputIT last)</td></tr>
<tr class="memdesc:af97b4fcd01509076c8a7b32ec1a10aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a JSON container given an iterator range  <a href="classbasic__json.html#af97b4fcd01509076c8a7b32ec1a10aec">More...</a><br /></td></tr>
<tr class="separator:af97b4fcd01509076c8a7b32ec1a10aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6712795591ec744415b50bc01d768ed"><td class="memTemplParams" colspan="2"><a id="ab6712795591ec744415b50bc01d768ed"></a>
template&lt;typename JsonRef , detail::enable_if_t&lt; detail::conjunction&lt; detail::is_json_ref&lt; JsonRef &gt;, std::is_same&lt; typename JsonRef::value_type, basic_json &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab6712795591ec744415b50bc01d768ed"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_json</b> (const JsonRef &amp;ref)</td></tr>
<tr class="separator:ab6712795591ec744415b50bc01d768ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15244e1249b6e7282127d460b5b2e3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af15244e1249b6e7282127d460b5b2e3e">basic_json</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;other)</td></tr>
<tr class="memdesc:af15244e1249b6e7282127d460b5b2e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="classbasic__json.html#af15244e1249b6e7282127d460b5b2e3e">More...</a><br /></td></tr>
<tr class="separator:af15244e1249b6e7282127d460b5b2e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18629aae4bd76e6f7920cf4e7b4dd60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae18629aae4bd76e6f7920cf4e7b4dd60">basic_json</a> (<a class="el" href="classbasic__json.html">basic_json</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ae18629aae4bd76e6f7920cf4e7b4dd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor  <a href="classbasic__json.html#ae18629aae4bd76e6f7920cf4e7b4dd60">More...</a><br /></td></tr>
<tr class="separator:ae18629aae4bd76e6f7920cf4e7b4dd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b20f4ac45a0f6e5ac2a2fb6138c19f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html">basic_json</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab0b20f4ac45a0f6e5ac2a2fb6138c19f">operator=</a> (<a class="el" href="classbasic__json.html">basic_json</a> other) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; json_value &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; json_value &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; json_base_class_t &gt;::<a class="el" href="classbasic__json.html#a80c2436388fd16a1529ce9afce8229ef">value</a>)</td></tr>
<tr class="memdesc:ab0b20f4ac45a0f6e5ac2a2fb6138c19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assignment  <a href="classbasic__json.html#ab0b20f4ac45a0f6e5ac2a2fb6138c19f">More...</a><br /></td></tr>
<tr class="separator:ab0b20f4ac45a0f6e5ac2a2fb6138c19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3bcb6dc54f447ad95085715104494e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9f3bcb6dc54f447ad95085715104494e">~basic_json</a> () noexcept</td></tr>
<tr class="memdesc:a9f3bcb6dc54f447ad95085715104494e"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="classbasic__json.html#a9f3bcb6dc54f447ad95085715104494e">More...</a><br /></td></tr>
<tr class="separator:a9f3bcb6dc54f447ad95085715104494e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">binary serialization/deserialization support</h2></td></tr>
<tr class="memitem:a9bea2fdeaff0956562cafd89fdba9139"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9bea2fdeaff0956562cafd89fdba9139">to_cbor</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:a9bea2fdeaff0956562cafd89fdba9139"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a CBOR serialization of a given JSON value  <a href="classbasic__json.html#a9bea2fdeaff0956562cafd89fdba9139">More...</a><br /></td></tr>
<tr class="separator:a9bea2fdeaff0956562cafd89fdba9139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706ccab0e47bd75cd36911db84451cd1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a706ccab0e47bd75cd36911db84451cd1">to_cbor</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o)</td></tr>
<tr class="memdesc:a706ccab0e47bd75cd36911db84451cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a CBOR serialization of a given JSON value  <a href="classbasic__json.html#a706ccab0e47bd75cd36911db84451cd1">More...</a><br /></td></tr>
<tr class="separator:a706ccab0e47bd75cd36911db84451cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31f5ee23264fb21bd31e16bc27adab2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af31f5ee23264fb21bd31e16bc27adab2">to_cbor</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o)</td></tr>
<tr class="memdesc:af31f5ee23264fb21bd31e16bc27adab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a CBOR serialization of a given JSON value  <a href="classbasic__json.html#af31f5ee23264fb21bd31e16bc27adab2">More...</a><br /></td></tr>
<tr class="separator:af31f5ee23264fb21bd31e16bc27adab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad317526e90c898957af9ce1c8c011caa"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad317526e90c898957af9ce1c8c011caa">to_msgpack</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:ad317526e90c898957af9ce1c8c011caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a MessagePack serialization of a given JSON value  <a href="classbasic__json.html#ad317526e90c898957af9ce1c8c011caa">More...</a><br /></td></tr>
<tr class="separator:ad317526e90c898957af9ce1c8c011caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46fdac62559d4c38e623d99ad7064e9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af46fdac62559d4c38e623d99ad7064e9">to_msgpack</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o)</td></tr>
<tr class="memdesc:af46fdac62559d4c38e623d99ad7064e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a MessagePack serialization of a given JSON value  <a href="classbasic__json.html#af46fdac62559d4c38e623d99ad7064e9">More...</a><br /></td></tr>
<tr class="separator:af46fdac62559d4c38e623d99ad7064e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51da13ff4e850d4ad1cf23ce4f3b9e4a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a51da13ff4e850d4ad1cf23ce4f3b9e4a">to_msgpack</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o)</td></tr>
<tr class="memdesc:a51da13ff4e850d4ad1cf23ce4f3b9e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a MessagePack serialization of a given JSON value  <a href="classbasic__json.html#a51da13ff4e850d4ad1cf23ce4f3b9e4a">More...</a><br /></td></tr>
<tr class="separator:a51da13ff4e850d4ad1cf23ce4f3b9e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6d27aedd29bed0cd145638f4f32fdc"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afa6d27aedd29bed0cd145638f4f32fdc">to_ubjson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:afa6d27aedd29bed0cd145638f4f32fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a UBJSON serialization of a given JSON value  <a href="classbasic__json.html#afa6d27aedd29bed0cd145638f4f32fdc">More...</a><br /></td></tr>
<tr class="separator:afa6d27aedd29bed0cd145638f4f32fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3d71f1dcfea24465d364b815d11445"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ada3d71f1dcfea24465d364b815d11445">to_ubjson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:ada3d71f1dcfea24465d364b815d11445"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a UBJSON serialization of a given JSON value  <a href="classbasic__json.html#ada3d71f1dcfea24465d364b815d11445">More...</a><br /></td></tr>
<tr class="separator:ada3d71f1dcfea24465d364b815d11445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b6c6cc3ba1b49af628fe0ec8c73b77"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab8b6c6cc3ba1b49af628fe0ec8c73b77">to_ubjson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:ab8b6c6cc3ba1b49af628fe0ec8c73b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a UBJSON serialization of a given JSON value  <a href="classbasic__json.html#ab8b6c6cc3ba1b49af628fe0ec8c73b77">More...</a><br /></td></tr>
<tr class="separator:ab8b6c6cc3ba1b49af628fe0ec8c73b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af410354f1c82a34f388e438cc47c31f8"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af410354f1c82a34f388e438cc47c31f8">to_bjdata</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:af410354f1c82a34f388e438cc47c31f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BJData serialization of a given JSON value  <a href="classbasic__json.html#af410354f1c82a34f388e438cc47c31f8">More...</a><br /></td></tr>
<tr class="separator:af410354f1c82a34f388e438cc47c31f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2736658c256401394059599f97139ee9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2736658c256401394059599f97139ee9">to_bjdata</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a2736658c256401394059599f97139ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BJData serialization of a given JSON value  <a href="classbasic__json.html#a2736658c256401394059599f97139ee9">More...</a><br /></td></tr>
<tr class="separator:a2736658c256401394059599f97139ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa9828fcbe4e33c9a036834564f7dbd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1fa9828fcbe4e33c9a036834564f7dbd">to_bjdata</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a1fa9828fcbe4e33c9a036834564f7dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BJData serialization of a given JSON value  <a href="classbasic__json.html#a1fa9828fcbe4e33c9a036834564f7dbd">More...</a><br /></td></tr>
<tr class="separator:a1fa9828fcbe4e33c9a036834564f7dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0945ada0a9b5afd776b2d6ea2c048a5"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae0945ada0a9b5afd776b2d6ea2c048a5">to_bson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:ae0945ada0a9b5afd776b2d6ea2c048a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BSON serialization of a given JSON value  <a href="classbasic__json.html#ae0945ada0a9b5afd776b2d6ea2c048a5">More...</a><br /></td></tr>
<tr class="separator:ae0945ada0a9b5afd776b2d6ea2c048a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd718b745034da1f4eea4c69f45cebda"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afd718b745034da1f4eea4c69f45cebda">to_bson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt; o)</td></tr>
<tr class="memdesc:afd718b745034da1f4eea4c69f45cebda"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BSON serialization of a given JSON value  <a href="classbasic__json.html#afd718b745034da1f4eea4c69f45cebda">More...</a><br /></td></tr>
<tr class="separator:afd718b745034da1f4eea4c69f45cebda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71794547dde3dd67e444aa45131ca861"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a71794547dde3dd67e444aa45131ca861">to_bson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, <a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt; o)</td></tr>
<tr class="memdesc:a71794547dde3dd67e444aa45131ca861"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BSON serialization of a given JSON value  <a href="classbasic__json.html#a71794547dde3dd67e444aa45131ca861">More...</a><br /></td></tr>
<tr class="separator:a71794547dde3dd67e444aa45131ca861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc3c67eaf6e9b22c8b446f9695249e9"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a5bc3c67eaf6e9b22c8b446f9695249e9"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5bc3c67eaf6e9b22c8b446f9695249e9">from_cbor</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="memdesc:a5bc3c67eaf6e9b22c8b446f9695249e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in CBOR format  <a href="classbasic__json.html#a5bc3c67eaf6e9b22c8b446f9695249e9">More...</a><br /></td></tr>
<tr class="separator:a5bc3c67eaf6e9b22c8b446f9695249e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ab03513b96f5a864bf623aeb70f122"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a08ab03513b96f5a864bf623aeb70f122"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a08ab03513b96f5a864bf623aeb70f122">from_cbor</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="memdesc:a08ab03513b96f5a864bf623aeb70f122"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in CBOR format  <a href="classbasic__json.html#a08ab03513b96f5a864bf623aeb70f122">More...</a><br /></td></tr>
<tr class="separator:a08ab03513b96f5a864bf623aeb70f122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a8b31922ebb7a637e723ac7873fa4a"><td class="memTemplParams" colspan="2"><a id="a89a8b31922ebb7a637e723ac7873fa4a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a89a8b31922ebb7a637e723ac7873fa4a"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>from_cbor</b> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="separator:a89a8b31922ebb7a637e723ac7873fa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8680ff0784c185b6898839a98de88486"><td class="memItemLeft" align="right" valign="top"><a id="a8680ff0784c185b6898839a98de88486"></a>
static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><b>from_cbor</b> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=<a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a>)</td></tr>
<tr class="separator:a8680ff0784c185b6898839a98de88486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c025488572f913ca5529a2ef62d066"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:ab0c025488572f913ca5529a2ef62d066"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab0c025488572f913ca5529a2ef62d066">from_msgpack</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:ab0c025488572f913ca5529a2ef62d066"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in MessagePack format  <a href="classbasic__json.html#ab0c025488572f913ca5529a2ef62d066">More...</a><br /></td></tr>
<tr class="separator:ab0c025488572f913ca5529a2ef62d066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d84b161b2d93f9b2b3ac8d68afeb96"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:af7d84b161b2d93f9b2b3ac8d68afeb96"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af7d84b161b2d93f9b2b3ac8d68afeb96">from_msgpack</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:af7d84b161b2d93f9b2b3ac8d68afeb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in MessagePack format  <a href="classbasic__json.html#af7d84b161b2d93f9b2b3ac8d68afeb96">More...</a><br /></td></tr>
<tr class="separator:af7d84b161b2d93f9b2b3ac8d68afeb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a721efc291300b45ac410ab75b8478b"><td class="memTemplParams" colspan="2"><a id="a2a721efc291300b45ac410ab75b8478b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a721efc291300b45ac410ab75b8478b"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>from_msgpack</b> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a2a721efc291300b45ac410ab75b8478b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c5fdb783d4f97a9062ab41809ec0c6"><td class="memItemLeft" align="right" valign="top"><a id="ae8c5fdb783d4f97a9062ab41809ec0c6"></a>
static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><b>from_msgpack</b> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:ae8c5fdb783d4f97a9062ab41809ec0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4588941095d03624ada4f0023d93944a"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a4588941095d03624ada4f0023d93944a"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4588941095d03624ada4f0023d93944a">from_ubjson</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a4588941095d03624ada4f0023d93944a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in UBJSON format  <a href="classbasic__json.html#a4588941095d03624ada4f0023d93944a">More...</a><br /></td></tr>
<tr class="separator:a4588941095d03624ada4f0023d93944a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd7470a3be83b27cf162c0261e6b63d"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a5dd7470a3be83b27cf162c0261e6b63d"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5dd7470a3be83b27cf162c0261e6b63d">from_ubjson</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a5dd7470a3be83b27cf162c0261e6b63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in UBJSON format  <a href="classbasic__json.html#a5dd7470a3be83b27cf162c0261e6b63d">More...</a><br /></td></tr>
<tr class="separator:a5dd7470a3be83b27cf162c0261e6b63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa375318d8ef6052fd4d606d596d9c424"><td class="memTemplParams" colspan="2"><a id="aa375318d8ef6052fd4d606d596d9c424"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa375318d8ef6052fd4d606d596d9c424"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>from_ubjson</b> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:aa375318d8ef6052fd4d606d596d9c424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad915ce03b8ec612764bb67d09e658a0d"><td class="memItemLeft" align="right" valign="top"><a id="ad915ce03b8ec612764bb67d09e658a0d"></a>
static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><b>from_ubjson</b> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:ad915ce03b8ec612764bb67d09e658a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59327f708c0555e2928487bcddf71293"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a59327f708c0555e2928487bcddf71293"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a59327f708c0555e2928487bcddf71293">from_bjdata</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a59327f708c0555e2928487bcddf71293"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BJData format  <a href="classbasic__json.html#a59327f708c0555e2928487bcddf71293">More...</a><br /></td></tr>
<tr class="separator:a59327f708c0555e2928487bcddf71293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf7ae6f9b2fee171484c5ef54f08d1e"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:accf7ae6f9b2fee171484c5ef54f08d1e"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#accf7ae6f9b2fee171484c5ef54f08d1e">from_bjdata</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:accf7ae6f9b2fee171484c5ef54f08d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BJData format  <a href="classbasic__json.html#accf7ae6f9b2fee171484c5ef54f08d1e">More...</a><br /></td></tr>
<tr class="separator:accf7ae6f9b2fee171484c5ef54f08d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0dfca88b11ea59a2568707767622d8"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a4b0dfca88b11ea59a2568707767622d8"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4b0dfca88b11ea59a2568707767622d8">from_bson</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a4b0dfca88b11ea59a2568707767622d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BSON format  <a href="classbasic__json.html#a4b0dfca88b11ea59a2568707767622d8">More...</a><br /></td></tr>
<tr class="separator:a4b0dfca88b11ea59a2568707767622d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2513159e8df9a81bf03ed34e1147b42e"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a2513159e8df9a81bf03ed34e1147b42e"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2513159e8df9a81bf03ed34e1147b42e">from_bson</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a2513159e8df9a81bf03ed34e1147b42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BSON format  <a href="classbasic__json.html#a2513159e8df9a81bf03ed34e1147b42e">More...</a><br /></td></tr>
<tr class="separator:a2513159e8df9a81bf03ed34e1147b42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e33baaab9ab497f0fe6b797134c9524"><td class="memTemplParams" colspan="2"><a id="a7e33baaab9ab497f0fe6b797134c9524"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e33baaab9ab497f0fe6b797134c9524"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>from_bson</b> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a7e33baaab9ab497f0fe6b797134c9524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9761fba9571455a96309f7ba647757"><td class="memItemLeft" align="right" valign="top"><a id="aed9761fba9571455a96309f7ba647757"></a>
static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><b>from_bson</b> (<a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:aed9761fba9571455a96309f7ba647757"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON Patch functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp440f929bef0e9348b145a71c542fb0c3"></a>return flattened JSON value</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/flatten/">https://json.nlohmann.me/api/basic_json/flatten/</a></dd></dl>
<p>unflatten a previously flattened JSON value </p><dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/unflatten/">https://json.nlohmann.me/api/basic_json/unflatten/</a> </dd></dl>
</td></tr>
<tr class="memitem:a699ef418df577e75f28dfce6b04d6c2f"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a699ef418df577e75f28dfce6b04d6c2f">diff</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;source, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;target, const std::string &amp;path=&quot;&quot;)</td></tr>
<tr class="memdesc:a699ef418df577e75f28dfce6b04d6c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a diff as a JSON patch  <a href="classbasic__json.html#a699ef418df577e75f28dfce6b04d6c2f">More...</a><br /></td></tr>
<tr class="separator:a699ef418df577e75f28dfce6b04d6c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145a004c0a2fa5be84b260ecc98ab5d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a145a004c0a2fa5be84b260ecc98ab5d9">patch</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;json_patch) const</td></tr>
<tr class="memdesc:a145a004c0a2fa5be84b260ecc98ab5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a JSON patch to a copy of the current object  <a href="classbasic__json.html#a145a004c0a2fa5be84b260ecc98ab5d9">More...</a><br /></td></tr>
<tr class="separator:a145a004c0a2fa5be84b260ecc98ab5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">object inspection</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbbb01a37b8f261ae5b5799058dcac1a0"></a>Functions to inspect the type of a JSON value. </p>
</td></tr>
<tr class="memitem:a85df48caed9e341bb14d98ab88891d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a85df48caed9e341bb14d98ab88891d1e">dump</a> (const int indent=-1, const char indent_char=' ', const bool ensure_ascii=false, const <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">error_handler_t</a> error_handler=error_handler_t::strict) const</td></tr>
<tr class="memdesc:a85df48caed9e341bb14d98ab88891d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialization  <a href="classbasic__json.html#a85df48caed9e341bb14d98ab88891d1e">More...</a><br /></td></tr>
<tr class="separator:a85df48caed9e341bb14d98ab88891d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e52dbb3cb4e9fcabd1b88c37985aef"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac5e52dbb3cb4e9fcabd1b88c37985aef">type</a> () const noexcept</td></tr>
<tr class="memdesc:ac5e52dbb3cb4e9fcabd1b88c37985aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the type of the JSON value (explicit)  <a href="classbasic__json.html#ac5e52dbb3cb4e9fcabd1b88c37985aef">More...</a><br /></td></tr>
<tr class="separator:ac5e52dbb3cb4e9fcabd1b88c37985aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad650dd5a7e019b970abce3d8864b5654"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad650dd5a7e019b970abce3d8864b5654">is_primitive</a> () const noexcept</td></tr>
<tr class="memdesc:ad650dd5a7e019b970abce3d8864b5654"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether type is primitive  <a href="classbasic__json.html#ad650dd5a7e019b970abce3d8864b5654">More...</a><br /></td></tr>
<tr class="separator:ad650dd5a7e019b970abce3d8864b5654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3a5f8761bc6f163f4119bddaf7b092"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2d3a5f8761bc6f163f4119bddaf7b092">is_structured</a> () const noexcept</td></tr>
<tr class="memdesc:a2d3a5f8761bc6f163f4119bddaf7b092"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether type is structured  <a href="classbasic__json.html#a2d3a5f8761bc6f163f4119bddaf7b092">More...</a><br /></td></tr>
<tr class="separator:a2d3a5f8761bc6f163f4119bddaf7b092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8789d0a365d5afaab61e7492908d8b2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad8789d0a365d5afaab61e7492908d8b2">is_null</a> () const noexcept</td></tr>
<tr class="memdesc:ad8789d0a365d5afaab61e7492908d8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is null  <a href="classbasic__json.html#ad8789d0a365d5afaab61e7492908d8b2">More...</a><br /></td></tr>
<tr class="separator:ad8789d0a365d5afaab61e7492908d8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe2e3c359b545f8edbb72f6bd78718c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#acfe2e3c359b545f8edbb72f6bd78718c">is_boolean</a> () const noexcept</td></tr>
<tr class="memdesc:acfe2e3c359b545f8edbb72f6bd78718c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a boolean  <a href="classbasic__json.html#acfe2e3c359b545f8edbb72f6bd78718c">More...</a><br /></td></tr>
<tr class="separator:acfe2e3c359b545f8edbb72f6bd78718c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf244be5088fb183f4ba21a66af9631"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aacf244be5088fb183f4ba21a66af9631">is_number</a> () const noexcept</td></tr>
<tr class="memdesc:aacf244be5088fb183f4ba21a66af9631"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a number  <a href="classbasic__json.html#aacf244be5088fb183f4ba21a66af9631">More...</a><br /></td></tr>
<tr class="separator:aacf244be5088fb183f4ba21a66af9631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2330e35cda16540058fef090abc709bf"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2330e35cda16540058fef090abc709bf">is_number_integer</a> () const noexcept</td></tr>
<tr class="memdesc:a2330e35cda16540058fef090abc709bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an integer number  <a href="classbasic__json.html#a2330e35cda16540058fef090abc709bf">More...</a><br /></td></tr>
<tr class="separator:a2330e35cda16540058fef090abc709bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de72635745144ee519157d23fe7189a"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4de72635745144ee519157d23fe7189a">is_number_unsigned</a> () const noexcept</td></tr>
<tr class="memdesc:a4de72635745144ee519157d23fe7189a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an unsigned integer number  <a href="classbasic__json.html#a4de72635745144ee519157d23fe7189a">More...</a><br /></td></tr>
<tr class="separator:a4de72635745144ee519157d23fe7189a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5bb82dfc8cceae1753b52a588eef92"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8d5bb82dfc8cceae1753b52a588eef92">is_number_float</a> () const noexcept</td></tr>
<tr class="memdesc:a8d5bb82dfc8cceae1753b52a588eef92"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a floating-point number  <a href="classbasic__json.html#a8d5bb82dfc8cceae1753b52a588eef92">More...</a><br /></td></tr>
<tr class="separator:a8d5bb82dfc8cceae1753b52a588eef92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af355a2b131068acf3d623eb6d80a711c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af355a2b131068acf3d623eb6d80a711c">is_object</a> () const noexcept</td></tr>
<tr class="memdesc:af355a2b131068acf3d623eb6d80a711c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an object  <a href="classbasic__json.html#af355a2b131068acf3d623eb6d80a711c">More...</a><br /></td></tr>
<tr class="separator:af355a2b131068acf3d623eb6d80a711c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184ba4a6b47e6da3703af19349bd776f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a184ba4a6b47e6da3703af19349bd776f">is_array</a> () const noexcept</td></tr>
<tr class="memdesc:a184ba4a6b47e6da3703af19349bd776f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an array  <a href="classbasic__json.html#a184ba4a6b47e6da3703af19349bd776f">More...</a><br /></td></tr>
<tr class="separator:a184ba4a6b47e6da3703af19349bd776f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007ecebde9a7d40714e300ce0ff52908"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a007ecebde9a7d40714e300ce0ff52908">is_string</a> () const noexcept</td></tr>
<tr class="memdesc:a007ecebde9a7d40714e300ce0ff52908"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a string  <a href="classbasic__json.html#a007ecebde9a7d40714e300ce0ff52908">More...</a><br /></td></tr>
<tr class="separator:a007ecebde9a7d40714e300ce0ff52908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdd993df08641faa3e24b5d2151e8f8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abbdd993df08641faa3e24b5d2151e8f8">is_binary</a> () const noexcept</td></tr>
<tr class="memdesc:abbdd993df08641faa3e24b5d2151e8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a binary array  <a href="classbasic__json.html#abbdd993df08641faa3e24b5d2151e8f8">More...</a><br /></td></tr>
<tr class="separator:abbdd993df08641faa3e24b5d2151e8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e4946a414cc978b88939ed1b343d46"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a39e4946a414cc978b88939ed1b343d46">is_discarded</a> () const noexcept</td></tr>
<tr class="memdesc:a39e4946a414cc978b88939ed1b343d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is discarded  <a href="classbasic__json.html#a39e4946a414cc978b88939ed1b343d46">More...</a><br /></td></tr>
<tr class="separator:a39e4946a414cc978b88939ed1b343d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e1c8fbdb62f3f8bc04e69eef9cc9cf"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a70e1c8fbdb62f3f8bc04e69eef9cc9cf">operator value_t</a> () const noexcept</td></tr>
<tr class="memdesc:a70e1c8fbdb62f3f8bc04e69eef9cc9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the type of the JSON value (implicit)  <a href="classbasic__json.html#a70e1c8fbdb62f3f8bc04e69eef9cc9cf">More...</a><br /></td></tr>
<tr class="separator:a70e1c8fbdb62f3f8bc04e69eef9cc9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">lookup</h2></td></tr>
<tr class="memitem:a727e3cfb5a874314d8deb12cb53a8105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a727e3cfb5a874314d8deb12cb53a8105">find</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:a727e3cfb5a874314d8deb12cb53a8105"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="classbasic__json.html#a727e3cfb5a874314d8deb12cb53a8105">More...</a><br /></td></tr>
<tr class="separator:a727e3cfb5a874314d8deb12cb53a8105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf93ae61eb63a9e543cafb3f723900c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7bf93ae61eb63a9e543cafb3f723900c">find</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:a7bf93ae61eb63a9e543cafb3f723900c"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="classbasic__json.html#a7bf93ae61eb63a9e543cafb3f723900c">More...</a><br /></td></tr>
<tr class="separator:a7bf93ae61eb63a9e543cafb3f723900c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dd769ce700326266883ba96a98a8f2"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a89dd769ce700326266883ba96a98a8f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a89dd769ce700326266883ba96a98a8f2">find</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:a89dd769ce700326266883ba96a98a8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="classbasic__json.html#a89dd769ce700326266883ba96a98a8f2">More...</a><br /></td></tr>
<tr class="separator:a89dd769ce700326266883ba96a98a8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1bb257797042aef7142c91f35390d8"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afe1bb257797042aef7142c91f35390d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afe1bb257797042aef7142c91f35390d8">find</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:afe1bb257797042aef7142c91f35390d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <a href="classbasic__json.html#afe1bb257797042aef7142c91f35390d8">More...</a><br /></td></tr>
<tr class="separator:afe1bb257797042aef7142c91f35390d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e1eff03a320299e6a8639a7579ca46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad1e1eff03a320299e6a8639a7579ca46">count</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:ad1e1eff03a320299e6a8639a7579ca46"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of occurrences of a key in a JSON object  <a href="classbasic__json.html#ad1e1eff03a320299e6a8639a7579ca46">More...</a><br /></td></tr>
<tr class="separator:ad1e1eff03a320299e6a8639a7579ca46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba1cd73d36a2cd58a9da7021b0f7317"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1ba1cd73d36a2cd58a9da7021b0f7317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1ba1cd73d36a2cd58a9da7021b0f7317">count</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:a1ba1cd73d36a2cd58a9da7021b0f7317"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of occurrences of a key in a JSON object  <a href="classbasic__json.html#a1ba1cd73d36a2cd58a9da7021b0f7317">More...</a><br /></td></tr>
<tr class="separator:a1ba1cd73d36a2cd58a9da7021b0f7317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5ea67fe1a4778be5189423e2545d7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afd5ea67fe1a4778be5189423e2545d7a">contains</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:afd5ea67fe1a4778be5189423e2545d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the existence of an element in a JSON object  <a href="classbasic__json.html#afd5ea67fe1a4778be5189423e2545d7a">More...</a><br /></td></tr>
<tr class="separator:afd5ea67fe1a4778be5189423e2545d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7053bdd8e9ee2fcb0ca9c54ec85f1297"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7053bdd8e9ee2fcb0ca9c54ec85f1297"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7053bdd8e9ee2fcb0ca9c54ec85f1297">contains</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:a7053bdd8e9ee2fcb0ca9c54ec85f1297"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the existence of an element in a JSON object  <a href="classbasic__json.html#a7053bdd8e9ee2fcb0ca9c54ec85f1297">More...</a><br /></td></tr>
<tr class="separator:a7053bdd8e9ee2fcb0ca9c54ec85f1297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c37affef3aa8c79cab9f3bfa2cb5e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac4c37affef3aa8c79cab9f3bfa2cb5e1">contains</a> (const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;ptr) const</td></tr>
<tr class="memdesc:ac4c37affef3aa8c79cab9f3bfa2cb5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the existence of an element in a JSON object given a JSON pointer  <a href="classbasic__json.html#ac4c37affef3aa8c79cab9f3bfa2cb5e1">More...</a><br /></td></tr>
<tr class="separator:ac4c37affef3aa8c79cab9f3bfa2cb5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON Pointer functions</h2></td></tr>
<tr class="memitem:a274307158c76b820701077dd471cc75b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a274307158c76b820701077dd471cc75b">operator[]</a> (const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;ptr)</td></tr>
<tr class="memdesc:a274307158c76b820701077dd471cc75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <a href="classbasic__json.html#a274307158c76b820701077dd471cc75b">More...</a><br /></td></tr>
<tr class="separator:a274307158c76b820701077dd471cc75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ef76e450ec1bf467c72535becc0be6"><td class="memTemplParams" colspan="2"><a id="af9ef76e450ec1bf467c72535becc0be6"></a>
template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af9ef76e450ec1bf467c72535becc0be6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>JSON_HEDLEY_DEPRECATED_FOR</b> (3.11.0, <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">basic_json::json_pointer</a> or nlohmann::json_pointer&lt; <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">basic_json::string_t</a> &gt;) <a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> operator[](const</td></tr>
<tr class="separator:af9ef76e450ec1bf467c72535becc0be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aedef6230f66b1271d71a6f77e7fed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6aedef6230f66b1271d71a6f77e7fed3">operator[]</a> (const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;ptr) const</td></tr>
<tr class="memdesc:a6aedef6230f66b1271d71a6f77e7fed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <a href="classbasic__json.html#a6aedef6230f66b1271d71a6f77e7fed3">More...</a><br /></td></tr>
<tr class="separator:a6aedef6230f66b1271d71a6f77e7fed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174114f78e24693f61dae1840af50979"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a174114f78e24693f61dae1840af50979"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a174114f78e24693f61dae1840af50979">JSON_HEDLEY_DEPRECATED_FOR</a> (3.11.0, <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">basic_json::json_pointer</a> or nlohmann::json_pointer&lt; <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">basic_json::string_t</a> &gt;) const _reference operator[](const</td></tr>
<tr class="memdesc:a174114f78e24693f61dae1840af50979"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <a href="classbasic__json.html#a174114f78e24693f61dae1840af50979">More...</a><br /></td></tr>
<tr class="separator:a174114f78e24693f61dae1840af50979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c01c57845336ed472ccc68be13c364c"><td class="memTemplParams" colspan="2"><a id="a2c01c57845336ed472ccc68be13c364c"></a>
template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2c01c57845336ed472ccc68be13c364c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>JSON_HEDLEY_DEPRECATED_FOR</b> (3.11.0, <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">basic_json::json_pointer</a> or nlohmann::json_pointer&lt; <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">basic_json::string_t</a> &gt;) <a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html#a899e4623fe377af5c9ad14c40c64280c">at</a>(const</td></tr>
<tr class="separator:a2c01c57845336ed472ccc68be13c364c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3a35d456e3250640a90c6f7a7fd555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5a3a35d456e3250640a90c6f7a7fd555">at</a> (const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;ptr) const</td></tr>
<tr class="memdesc:a5a3a35d456e3250640a90c6f7a7fd555"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <a href="classbasic__json.html#a5a3a35d456e3250640a90c6f7a7fd555">More...</a><br /></td></tr>
<tr class="separator:a5a3a35d456e3250640a90c6f7a7fd555"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON Merge Patch functions</h2></td></tr>
<tr class="memitem:a8676ac2433fe299b8d420f00a0741395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8676ac2433fe299b8d420f00a0741395">merge_patch</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;apply_patch)</td></tr>
<tr class="memdesc:a8676ac2433fe299b8d420f00a0741395"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a JSON Merge Patch  <a href="classbasic__json.html#a8676ac2433fe299b8d420f00a0741395">More...</a><br /></td></tr>
<tr class="separator:a8676ac2433fe299b8d420f00a0741395"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass = void&gt;<br />
class basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;</h3>

<p>namespace for Niels Lohmann </p>
<p>a class to store JSON values </p><dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/">https://json.nlohmann.me/api/basic_json/</a></dd>
<dd>
<a href="https://github.com/nlohmann">https://github.com/nlohmann</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0</dd></dl>
<p>a class to store JSON values</p>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6b282cae56b331d222c7da4b05eab5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b282cae56b331d222c7da4b05eab5e8">&#9670;&nbsp;</a></span>array_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> =  ArrayType&lt;<a class="el" href="classbasic__json.html">basic_json</a>, AllocatorType&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/array_t/">https://json.nlohmann.me/api/basic_json/array_t/</a> </dd></dl>

</div>
</div>
<a id="a4c1b5ea434b48cf31097617bb1c1ca1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1b5ea434b48cf31097617bb1c1ca1e">&#9670;&nbsp;</a></span>binary_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> =  nlohmann::byte_container_with_subtype&lt;BinaryType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a packed binary type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary_t/">https://json.nlohmann.me/api/basic_json/binary_t/</a> </dd></dl>

</div>
</div>
<a id="a9301890c48e9b957edc07f9eb767bd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9301890c48e9b957edc07f9eb767bd10">&#9670;&nbsp;</a></span>boolean_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> =  BooleanType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a boolean </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/boolean_t/">https://json.nlohmann.me/api/basic_json/boolean_t/</a> </dd></dl>

</div>
</div>
<a id="a991d005e7f648cbf37bb36daf85183ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991d005e7f648cbf37bb36daf85183ca">&#9670;&nbsp;</a></span>default_object_comparator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a991d005e7f648cbf37bb36daf85183ca">default_object_comparator_t</a> =  std::less&lt;StringType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default object key comparator type The actual object key comparator type (<a class="el" href="classbasic__json.html#af12040e0663db54840d73d363979643a">object_comparator_t</a>) may be different. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/default_object_comparator_t/">https://json.nlohmann.me/api/basic_json/default_object_comparator_t/</a> </dd></dl>

</div>
</div>
<a id="a80a229dbc84c1334171ce9c49c873c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a229dbc84c1334171ce9c49c873c56">&#9670;&nbsp;</a></span>number_float_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a> =  NumberFloatType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (floating-point) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/number_float_t/">https://json.nlohmann.me/api/basic_json/number_float_t/</a> </dd></dl>

</div>
</div>
<a id="aba48b0bdee31228a4e19b7c040b6d2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba48b0bdee31228a4e19b7c040b6d2a5">&#9670;&nbsp;</a></span>number_integer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a> =  NumberIntegerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (integer) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/number_integer_t/">https://json.nlohmann.me/api/basic_json/number_integer_t/</a> </dd></dl>

</div>
</div>
<a id="ae8505b599e706768a1e0bd6718cc7117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8505b599e706768a1e0bd6718cc7117">&#9670;&nbsp;</a></span>number_unsigned_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a> =  NumberUnsignedType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (unsigned) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/number_unsigned_t/">https://json.nlohmann.me/api/basic_json/number_unsigned_t/</a> </dd></dl>

</div>
</div>
<a id="af12040e0663db54840d73d363979643a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12040e0663db54840d73d363979643a">&#9670;&nbsp;</a></span>object_comparator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#af12040e0663db54840d73d363979643a">object_comparator_t</a> =  detail::actual_object_comparator_t&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>object key comparator type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/object_comparator_t/">https://json.nlohmann.me/api/basic_json/object_comparator_t/</a> </dd></dl>

</div>
</div>
<a id="ac90f70623dc1ad761ea1c5013b2fee47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90f70623dc1ad761ea1c5013b2fee47">&#9670;&nbsp;</a></span>object_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> =  ObjectType&lt;StringType, <a class="el" href="classbasic__json.html">basic_json</a>, <a class="el" href="classbasic__json.html#a991d005e7f648cbf37bb36daf85183ca">default_object_comparator_t</a>, AllocatorType&lt;std::pair&lt;const StringType, <a class="el" href="classbasic__json.html">basic_json</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/object_t/">https://json.nlohmann.me/api/basic_json/object_t/</a> </dd></dl>

</div>
</div>
<a id="a53b6bf8ee18c48f4609c8bdd4bb95107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b6bf8ee18c48f4609c8bdd4bb95107">&#9670;&nbsp;</a></span>parse_event_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="namespacedetail.html#a47b1bb0bbd3596589ed9187059c312ef">parse_event_t</a> =  <a class="el" href="namespacedetail.html#a47b1bb0bbd3596589ed9187059c312ef">detail::parse_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parser event types </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/parse_event_t/">https://json.nlohmann.me/api/basic_json/parse_event_t/</a> </dd></dl>

</div>
</div>
<a id="a50644d655c9283aaf0e2a0f3a5428867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50644d655c9283aaf0e2a0f3a5428867">&#9670;&nbsp;</a></span>parser_callback_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#a50644d655c9283aaf0e2a0f3a5428867">parser_callback_t</a> =  detail::parser_callback_t&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>per-element parser callback type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/parser_callback_t/">https://json.nlohmann.me/api/basic_json/parser_callback_t/</a> </dd></dl>

</div>
</div>
<a id="ac8c9cde32146e6c343e1960aefc11fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c9cde32146e6c343e1960aefc11fba">&#9670;&nbsp;</a></span>string_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> =  StringType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a string </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/string_t/">https://json.nlohmann.me/api/basic_json/string_t/</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae2d5bc42270881ed3e219e8b1456fec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d5bc42270881ed3e219e8b1456fec5">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an empty value with a given type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="a5b1fab9ded0a2a182837bd66c0e5189e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1fab9ded0a2a182837bd66c0e5189e">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a null object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="a0f24e66b152203259eaf05c33ebaeed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f24e66b152203259eaf05c33ebaeed4">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename CompatibleType , typename U  = detail::uncvref_t&lt;CompatibleType&gt;, detail::enable_if_t&lt; !detail::is_basic_json&lt; U &gt;::value &amp;&amp;detail::is_compatible_type&lt; basic_json_t, U &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">CompatibleType &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from compatible types </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="aeaf10402e79a1acce9a74f5a9654d403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf10402e79a1acce9a74f5a9654d403">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value &amp;&amp;!std::is_same&lt; basic_json, BasicJsonType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an existing one </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="aa911d47d3c99184a301bf4fd304199b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa911d47d3c99184a301bf4fd304199b2">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>type_deduction</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td>
          <td class="paramname"><em>manual_type</em> = <code><a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632af1f713c9e000f5d3f280adbd124df4f5">value_t::array</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a container (array or object) from an initializer list </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="a7b6f0605b09a002567fd18a289cef31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6f0605b09a002567fd18a289cef31b">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct an array with count copies of given value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="af97b4fcd01509076c8a7b32ec1a10aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97b4fcd01509076c8a7b32ec1a10aec">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class InputIT , typename std::enable_if&lt; std::is_same&lt; InputIT, typename basic_json_t::iterator &gt;::value||std::is_same&lt; InputIT, typename basic_json_t::const_iterator &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">InputIT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIT&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct a JSON container given an iterator range </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="af15244e1249b6e7282127d460b5b2e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15244e1249b6e7282127d460b5b2e3e">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="ae18629aae4bd76e6f7920cf4e7b4dd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18629aae4bd76e6f7920cf4e7b4dd60">&#9670;&nbsp;</a></span>basic_json() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

</div>
</div>
<a id="a9f3bcb6dc54f447ad95085715104494e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3bcb6dc54f447ad95085715104494e">&#9670;&nbsp;</a></span>~basic_json()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::~<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/~basic_json/">https://json.nlohmann.me/api/basic_json/~basic_json/</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac736994a792cb8460a30a3f4dd86fd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac736994a792cb8460a30a3f4dd86fd78">&#9670;&nbsp;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create an array from an initializer list </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/array/">https://json.nlohmann.me/api/basic_json/array/</a> </dd></dl>

</div>
</div>
<a id="a5a3a35d456e3250640a90c6f7a7fd555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3a35d456e3250640a90c6f7a7fd555">&#9670;&nbsp;</a></span>at() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="accafaaf23f60bb245ddb1fa0972b33a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accafaaf23f60bb245ddb1fa0972b33a3">&#9670;&nbsp;</a></span>at() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="aba9a21714e81e98fc5786a2339ea1665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9a21714e81e98fc5786a2339ea1665">&#9670;&nbsp;</a></span>at() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="a4cd9ba2f2164d9cee83b07f76d40843f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd9ba2f2164d9cee83b07f76d40843f">&#9670;&nbsp;</a></span>at() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::at </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="a7ae6267ca4bd85e25f61dc5ba30204da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae6267ca4bd85e25f61dc5ba30204da">&#9670;&nbsp;</a></span>at() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::at </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="a899e4623fe377af5c9ad14c40c64280c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899e4623fe377af5c9ad14c40c64280c">&#9670;&nbsp;</a></span>at() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="af076d8a80f4263cf821da2033d5773b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af076d8a80f4263cf821da2033d5773b6">&#9670;&nbsp;</a></span>at() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="a0d93dc1dbdf67a6ee3a5cf1d2439ca77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d93dc1dbdf67a6ee3a5cf1d2439ca77">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the last element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/back/">https://json.nlohmann.me/api/basic_json/back/</a> </dd></dl>

</div>
</div>
<a id="a41eee3066cd1ebfea746f9f07fd03f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41eee3066cd1ebfea746f9f07fd03f6f">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the last element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/back/">https://json.nlohmann.me/api/basic_json/back/</a> </dd></dl>

</div>
</div>
<a id="a743ac3bcbc4b0f7897244d4cea387eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743ac3bcbc4b0f7897244d4cea387eee">&#9670;&nbsp;</a></span>binary() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">const typename binary_t::container_type &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

</div>
</div>
<a id="a45e65e73d9ecf780537d632372fa2c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e65e73d9ecf780537d632372fa2c51">&#9670;&nbsp;</a></span>binary() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">const typename binary_t::container_type &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename binary_t::subtype_type&#160;</td>
          <td class="paramname"><em>subtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (with subtype) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

</div>
</div>
<a id="a5af2196a9acde33f742ef054e7c2109c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af2196a9acde33f742ef054e7c2109c">&#9670;&nbsp;</a></span>binary() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">typename binary_t::container_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

</div>
</div>
<a id="ac00a2a38929ce21eae65f9dd09b03ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00a2a38929ce21eae65f9dd09b03ce3">&#9670;&nbsp;</a></span>binary() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">typename binary_t::container_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename binary_t::subtype_type&#160;</td>
          <td class="paramname"><em>subtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (with subtype) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

</div>
</div>
<a id="ac4c37affef3aa8c79cab9f3bfa2cb5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c37affef3aa8c79cab9f3bfa2cb5e1">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check the existence of an element in a JSON object given a JSON pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/contains/">https://json.nlohmann.me/api/basic_json/contains/</a> </dd></dl>

</div>
</div>
<a id="afd5ea67fe1a4778be5189423e2545d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5ea67fe1a4778be5189423e2545d7a">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check the existence of an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/contains/">https://json.nlohmann.me/api/basic_json/contains/</a> </dd></dl>

</div>
</div>
<a id="a7053bdd8e9ee2fcb0ca9c54ec85f1297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7053bdd8e9ee2fcb0ca9c54ec85f1297">&#9670;&nbsp;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check the existence of an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/contains/">https://json.nlohmann.me/api/basic_json/contains/</a> </dd></dl>

</div>
</div>
<a id="ad1e1eff03a320299e6a8639a7579ca46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e1eff03a320299e6a8639a7579ca46">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of occurrences of a key in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/count/">https://json.nlohmann.me/api/basic_json/count/</a> </dd></dl>

</div>
</div>
<a id="a1ba1cd73d36a2cd58a9da7021b0f7317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba1cd73d36a2cd58a9da7021b0f7317">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::count </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of occurrences of a key in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/count/">https://json.nlohmann.me/api/basic_json/count/</a> </dd></dl>

</div>
</div>
<a id="a699ef418df577e75f28dfce6b04d6c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699ef418df577e75f28dfce6b04d6c2f">&#9670;&nbsp;</a></span>diff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::diff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a diff as a JSON patch </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/diff/">https://json.nlohmann.me/api/basic_json/diff/</a> </dd></dl>

</div>
</div>
<a id="a85df48caed9e341bb14d98ab88891d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85df48caed9e341bb14d98ab88891d1e">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>indent_char</em> = <code>'&#160;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ensure_ascii</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">error_handler_t</a>&#160;</td>
          <td class="paramname"><em>error_handler</em> = <code>error_handler_t::strict</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serialization </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/dump/">https://json.nlohmann.me/api/basic_json/dump/</a> </dd></dl>

</div>
</div>
<a id="ac366495e80b2f51a09f07471006cde28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac366495e80b2f51a09f07471006cde28">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a>, bool&gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object if key does not exist </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/emplace/">https://json.nlohmann.me/api/basic_json/emplace/</a> </dd></dl>

</div>
</div>
<a id="ac5f0a15957842b188826aea98a9cfd3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f0a15957842b188826aea98a9cfd3d">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/emplace_back/">https://json.nlohmann.me/api/basic_json/emplace_back/</a> </dd></dl>

</div>
</div>
<a id="ac2c58b5f34c2ff56e27630214f5a9df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c58b5f34c2ff56e27630214f5a9df4">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element from a JSON array given an index </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

</div>
</div>
<a id="a05da3b93f2d4a7164589abffaa9acb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05da3b93f2d4a7164589abffaa9acb33">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element from a JSON object given a key </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

</div>
</div>
<a id="a437b81c6e968a4192a22bc0de6c4df80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437b81c6e968a4192a22bc0de6c4df80">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , detail::enable_if_t&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;::value||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratorType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove elements given an iterator range </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

</div>
</div>
<a id="a7d0fef086b1b72372113db6ce7446189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0fef086b1b72372113db6ce7446189">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , detail::enable_if_t&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;::value||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratorType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element given an iterator </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

</div>
</div>
<a id="a5f763336e84232f38e2d80e142f9820e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f763336e84232f38e2d80e142f9820e">&#9670;&nbsp;</a></span>erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element from a JSON object given a key </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

</div>
</div>
<a id="a727e3cfb5a874314d8deb12cb53a8105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727e3cfb5a874314d8deb12cb53a8105">&#9670;&nbsp;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

</div>
</div>
<a id="a7bf93ae61eb63a9e543cafb3f723900c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf93ae61eb63a9e543cafb3f723900c">&#9670;&nbsp;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

</div>
</div>
<a id="a89dd769ce700326266883ba96a98a8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89dd769ce700326266883ba96a98a8f2">&#9670;&nbsp;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::find </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

</div>
</div>
<a id="afe1bb257797042aef7142c91f35390d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1bb257797042aef7142c91f35390d8">&#9670;&nbsp;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::find </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

</div>
</div>
<a id="a59327f708c0555e2928487bcddf71293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59327f708c0555e2928487bcddf71293">&#9670;&nbsp;</a></span>from_bjdata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::from_bjdata </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BJData format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bjdata/">https://json.nlohmann.me/api/basic_json/from_bjdata/</a> </dd></dl>

</div>
</div>
<a id="accf7ae6f9b2fee171484c5ef54f08d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf7ae6f9b2fee171484c5ef54f08d1e">&#9670;&nbsp;</a></span>from_bjdata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::from_bjdata </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BJData format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bjdata/">https://json.nlohmann.me/api/basic_json/from_bjdata/</a> </dd></dl>

</div>
</div>
<a id="a4b0dfca88b11ea59a2568707767622d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0dfca88b11ea59a2568707767622d8">&#9670;&nbsp;</a></span>from_bson() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bson/">https://json.nlohmann.me/api/basic_json/from_bson/</a> </dd></dl>

</div>
</div>
<a id="a2513159e8df9a81bf03ed34e1147b42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2513159e8df9a81bf03ed34e1147b42e">&#9670;&nbsp;</a></span>from_bson() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bson/">https://json.nlohmann.me/api/basic_json/from_bson/</a> </dd></dl>

</div>
</div>
<a id="a5bc3c67eaf6e9b22c8b446f9695249e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc3c67eaf6e9b22c8b446f9695249e9">&#9670;&nbsp;</a></span>from_cbor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code><a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in CBOR format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_cbor/">https://json.nlohmann.me/api/basic_json/from_cbor/</a> </dd></dl>

</div>
</div>
<a id="a08ab03513b96f5a864bf623aeb70f122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ab03513b96f5a864bf623aeb70f122">&#9670;&nbsp;</a></span>from_cbor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code><a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592acb5e100e5a9a3e7f6d1fd97512215282">cbor_tag_handler_t::error</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in CBOR format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_cbor/">https://json.nlohmann.me/api/basic_json/from_cbor/</a> </dd></dl>

</div>
</div>
<a id="ab0c025488572f913ca5529a2ef62d066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c025488572f913ca5529a2ef62d066">&#9670;&nbsp;</a></span>from_msgpack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in MessagePack format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_msgpack/">https://json.nlohmann.me/api/basic_json/from_msgpack/</a> </dd></dl>

</div>
</div>
<a id="af7d84b161b2d93f9b2b3ac8d68afeb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d84b161b2d93f9b2b3ac8d68afeb96">&#9670;&nbsp;</a></span>from_msgpack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in MessagePack format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_msgpack/">https://json.nlohmann.me/api/basic_json/from_msgpack/</a> </dd></dl>

</div>
</div>
<a id="a4588941095d03624ada4f0023d93944a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4588941095d03624ada4f0023d93944a">&#9670;&nbsp;</a></span>from_ubjson() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in UBJSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_ubjson/">https://json.nlohmann.me/api/basic_json/from_ubjson/</a> </dd></dl>

</div>
</div>
<a id="a5dd7470a3be83b27cf162c0261e6b63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd7470a3be83b27cf162c0261e6b63d">&#9670;&nbsp;</a></span>from_ubjson() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in UBJSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_ubjson/">https://json.nlohmann.me/api/basic_json/from_ubjson/</a> </dd></dl>

</div>
</div>
<a id="a162089e94f24182ba3e4484be63c0c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162089e94f24182ba3e4484be63c0c1a">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the first element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/front/">https://json.nlohmann.me/api/basic_json/front/</a> </dd></dl>

</div>
</div>
<a id="a0ab31c7fdbab38898070bca01637f886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab31c7fdbab38898070bca01637f886">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ValueTypeCV , typename ValueType  = detail::uncvref_t&lt;ValueTypeCV&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const basic_json_t&amp;&gt;().template get_impl&lt;ValueType&gt;(<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt;4&gt; {}))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a (pointer) value (explicit) </p>
<p>Performs explicit type conversion between the JSON value and a compatible value if required.</p>
<ul>
<li>If the requested type is a pointer to the internally stored JSON value that pointer is returned. No copies are made.</li>
<li>If the requested type is the current <a class="el" href="classbasic__json.html">basic_json</a>, or a different <a class="el" href="classbasic__json.html">basic_json</a> convertible from the current <a class="el" href="classbasic__json.html">basic_json</a>.</li>
<li>Otherwise the value is converted by calling the json_serializer&lt;ValueType&gt; <code>from_json()</code> method.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueTypeCV</td><td>the provided value type </td></tr>
    <tr><td class="paramname">ValueType</td><td>the returned value type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the JSON value, converted to </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>if necessary</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">what</td><td>json_serializer&lt;ValueType&gt; <code>from_json()</code> method throws if conversion is required</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

</div>
</div>
<a id="ab11f66d4edc50a209fab3f8c48664a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11f66d4edc50a209fab3f8c48664a53">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;basic_json_t&amp;&gt;().template <a class="el" href="classbasic__json.html#aba60354728e2f7f64e3e5c6b02c5b820">get_ptr</a>&lt;PointerType&gt;())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (explicit) </p>
<p>Explicit pointer access to the internally stored JSON value. No copies are made.</p>
<dl class="section warning"><dt>Warning</dt><dd>The pointer becomes invalid if the underlying JSON object changes.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointerType</td><td>pointer type; must be a pointer to <a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a>, <a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a>, <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a>, <a class="el" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a>, <a class="el" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a>, <a class="el" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a>, or <a class="el" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the internally stored JSON value if the requested pointer type <em>PointerType</em> fits to the JSON value; <code>nullptr</code> otherwise</dd></dl>
<p>@complexity Constant.</p>
<p>@liveexample{The example below shows how pointers to internal values of a JSON value can be requested. Note that no type conversions are made and a <code>nullptr</code> is returned if the value and the requested pointer type does not match.,get__PointerType}</p>
<dl class="section see"><dt>See also</dt><dd>see <a class="el" href="classbasic__json.html#aba60354728e2f7f64e3e5c6b02c5b820">get_ptr()</a> for explicit pointer-member access</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

</div>
</div>
<a id="a4bceecf563151eb58af179416d8e6299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bceecf563151eb58af179416d8e6299">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbasic__json.html#a83f845db2d54cedad97279bad70aea52">allocator_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the allocator associated with the container </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_allocator/">https://json.nlohmann.me/api/basic_json/get_allocator/</a> </dd></dl>

</div>
</div>
<a id="ac55de1b3601085c32e4a1dc32ef6d32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55de1b3601085c32e4a1dc32ef6d32d">&#9670;&nbsp;</a></span>get_binary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a>&amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::get_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a binary value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_binary/">https://json.nlohmann.me/api/basic_json/get_binary/</a> </dd></dl>

</div>
</div>
<a id="a4ab13e0430cfea76c05ccd062aa528ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab13e0430cfea76c05ccd062aa528ec">&#9670;&nbsp;</a></span>get_binary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a>&amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::get_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a binary value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_binary/">https://json.nlohmann.me/api/basic_json/get_binary/</a> </dd></dl>

</div>
</div>
<a id="a9db8d5e59277a70a736f899c4aec0af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db8d5e59277a70a736f899c4aec0af0">&#9670;&nbsp;</a></span>get_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value &amp;&amp;std::is_const&lt; typename std::remove_pointer&lt; PointerType &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::get_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const basic_json_t&amp;&gt;().get_impl_ptr(std::declval&lt;PointerType&gt;()))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ptr/">https://json.nlohmann.me/api/basic_json/get_ptr/</a> </dd></dl>

</div>
</div>
<a id="aba60354728e2f7f64e3e5c6b02c5b820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba60354728e2f7f64e3e5c6b02c5b820">&#9670;&nbsp;</a></span>get_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::get_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;basic_json_t&amp;&gt;().get_impl_ptr(std::declval&lt;PointerType&gt;()))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ptr/">https://json.nlohmann.me/api/basic_json/get_ptr/</a> </dd></dl>

</div>
</div>
<a id="a3697078e748abc4a99c23e36e321b439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3697078e748abc4a99c23e36e321b439">&#9670;&nbsp;</a></span>get_ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReferenceType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::get_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reference value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ref/">https://json.nlohmann.me/api/basic_json/get_ref/</a> </dd></dl>

</div>
</div>
<a id="a39c5dbafcc6eef79143c251096827549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c5dbafcc6eef79143c251096827549">&#9670;&nbsp;</a></span>get_ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;::value &amp;&amp;std::is_const&lt; typename std::remove_reference&lt; ReferenceType &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReferenceType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::get_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reference value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ref/">https://json.nlohmann.me/api/basic_json/get_ref/</a> </dd></dl>

</div>
</div>
<a id="a055a78a155eef5fbf05d40899cc7eff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055a78a155eef5fbf05d40899cc7eff9">&#9670;&nbsp;</a></span>get_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , detail::enable_if_t&lt; !detail::is_basic_json&lt; ValueType &gt;::value &amp;&amp;detail::has_from_json&lt; basic_json_t, ValueType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType&amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::get_to </td>
          <td>(</td>
          <td class="paramtype">ValueType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a value (explicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_to/">https://json.nlohmann.me/api/basic_json/get_to/</a> </dd></dl>

</div>
</div>
<a id="aaf55c485c75ddd7bd5f9791e59d3aec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf55c485c75ddd7bd5f9791e59d3aec7">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts range of elements into object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

</div>
</div>
<a id="ae5da62116a40a0f86e87f11fdd54e9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5da62116a40a0f86e87f11fdd54e9f0">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts element into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

</div>
</div>
<a id="a7f3817060c2bec896a99cb2c236b9c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3817060c2bec896a99cb2c236b9c27">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts element into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

</div>
</div>
<a id="a68e1707248a00a2608a304da5ae5c911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e1707248a00a2608a304da5ae5c911">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts range of elements into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

</div>
</div>
<a id="abdfee6a3db80431a24c68bfaf038c47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfee6a3db80431a24c68bfaf038c47d">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts elements from initializer list into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

</div>
</div>
<a id="a47b623200562da188886a385c716d101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b623200562da188886a385c716d101">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts copies of element into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

</div>
</div>
<a id="af8c5ca19d22a32054452470669c43bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c5ca19d22a32054452470669c43bb9">&#9670;&nbsp;</a></span>insert_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ae206a491161d043f8efaa1330f1ccf97">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::insert_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper for insertion of an iterator </p><dl class="section note"><dt>Note</dt><dd>: This uses std::distance to support GCC 4.8, see <a href="https://github.com/nlohmann/json/pull/1257">https://github.com/nlohmann/json/pull/1257</a> </dd></dl>

</div>
</div>
<a id="a184ba4a6b47e6da3703af19349bd776f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184ba4a6b47e6da3703af19349bd776f">&#9670;&nbsp;</a></span>is_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::is_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_array/">https://json.nlohmann.me/api/basic_json/is_array/</a> </dd></dl>

</div>
</div>
<a id="abbdd993df08641faa3e24b5d2151e8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdd993df08641faa3e24b5d2151e8f8">&#9670;&nbsp;</a></span>is_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::is_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a binary array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_binary/">https://json.nlohmann.me/api/basic_json/is_binary/</a> </dd></dl>

</div>
</div>
<a id="acfe2e3c359b545f8edbb72f6bd78718c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe2e3c359b545f8edbb72f6bd78718c">&#9670;&nbsp;</a></span>is_boolean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::is_boolean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a boolean </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_boolean/">https://json.nlohmann.me/api/basic_json/is_boolean/</a> </dd></dl>

</div>
</div>
<a id="a39e4946a414cc978b88939ed1b343d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e4946a414cc978b88939ed1b343d46">&#9670;&nbsp;</a></span>is_discarded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::is_discarded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is discarded </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_discarded/">https://json.nlohmann.me/api/basic_json/is_discarded/</a> </dd></dl>

</div>
</div>
<a id="ad8789d0a365d5afaab61e7492908d8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8789d0a365d5afaab61e7492908d8b2">&#9670;&nbsp;</a></span>is_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::is_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is null </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_null/">https://json.nlohmann.me/api/basic_json/is_null/</a> </dd></dl>

</div>
</div>
<a id="aacf244be5088fb183f4ba21a66af9631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf244be5088fb183f4ba21a66af9631">&#9670;&nbsp;</a></span>is_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::is_number </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number/">https://json.nlohmann.me/api/basic_json/is_number/</a> </dd></dl>

</div>
</div>
<a id="a8d5bb82dfc8cceae1753b52a588eef92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5bb82dfc8cceae1753b52a588eef92">&#9670;&nbsp;</a></span>is_number_float()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::is_number_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a floating-point number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number_float/">https://json.nlohmann.me/api/basic_json/is_number_float/</a> </dd></dl>

</div>
</div>
<a id="a2330e35cda16540058fef090abc709bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2330e35cda16540058fef090abc709bf">&#9670;&nbsp;</a></span>is_number_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::is_number_integer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an integer number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number_integer/">https://json.nlohmann.me/api/basic_json/is_number_integer/</a> </dd></dl>

</div>
</div>
<a id="a4de72635745144ee519157d23fe7189a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de72635745144ee519157d23fe7189a">&#9670;&nbsp;</a></span>is_number_unsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::is_number_unsigned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an unsigned integer number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number_unsigned/">https://json.nlohmann.me/api/basic_json/is_number_unsigned/</a> </dd></dl>

</div>
</div>
<a id="af355a2b131068acf3d623eb6d80a711c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af355a2b131068acf3d623eb6d80a711c">&#9670;&nbsp;</a></span>is_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::is_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_object/">https://json.nlohmann.me/api/basic_json/is_object/</a> </dd></dl>

</div>
</div>
<a id="ad650dd5a7e019b970abce3d8864b5654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad650dd5a7e019b970abce3d8864b5654">&#9670;&nbsp;</a></span>is_primitive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::is_primitive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether type is primitive </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_primitive/">https://json.nlohmann.me/api/basic_json/is_primitive/</a> </dd></dl>

</div>
</div>
<a id="a007ecebde9a7d40714e300ce0ff52908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007ecebde9a7d40714e300ce0ff52908">&#9670;&nbsp;</a></span>is_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::is_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a string </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_string/">https://json.nlohmann.me/api/basic_json/is_string/</a> </dd></dl>

</div>
</div>
<a id="a2d3a5f8761bc6f163f4119bddaf7b092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3a5f8761bc6f163f4119bddaf7b092">&#9670;&nbsp;</a></span>is_structured()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::is_structured </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether type is structured </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_structured/">https://json.nlohmann.me/api/basic_json/is_structured/</a> </dd></dl>

</div>
</div>
<a id="a174114f78e24693f61dae1840af50979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174114f78e24693f61dae1840af50979">&#9670;&nbsp;</a></span>JSON_HEDLEY_DEPRECATED_FOR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::JSON_HEDLEY_DEPRECATED_FOR </td>
          <td>(</td>
          <td class="paramtype">3.11.&#160;</td>
          <td class="paramname"><em>0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> or nlohmann::json_pointer&lt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

</div>
</div>
<a id="a3b67977cfd161b73161fa9341f8a4158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b67977cfd161b73161fa9341f8a4158">&#9670;&nbsp;</a></span>JSON_HEDLEY_DEPRECATED_FOR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class BasicJsonType , detail::enable_if_t&lt; detail::is_basic_json&lt; BasicJsonType &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::JSON_HEDLEY_DEPRECATED_FOR </td>
          <td>(</td>
          <td class="paramtype">3.11.&#160;</td>
          <td class="paramname"><em>0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> or nlohmann::json_pointer&lt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::<a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the first element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/front/">https://json.nlohmann.me/api/basic_json/front/</a> </dd></dl>

</div>
</div>
<a id="a8676ac2433fe299b8d420f00a0741395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8676ac2433fe299b8d420f00a0741395">&#9670;&nbsp;</a></span>merge_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::merge_patch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>apply_patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applies a JSON Merge Patch </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/merge_patch/">https://json.nlohmann.me/api/basic_json/merge_patch/</a> </dd></dl>

</div>
</div>
<a id="a7b435c2ed2db99cb1daa78ae3c6c4580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b435c2ed2db99cb1daa78ae3c6c4580">&#9670;&nbsp;</a></span>meta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::meta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns version information on the library </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/meta/">https://json.nlohmann.me/api/basic_json/meta/</a> </dd></dl>

</div>
</div>
<a id="a50a0e8dacc0f4aa12162da666595e6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a0e8dacc0f4aa12162da666595e6fd">&#9670;&nbsp;</a></span>object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create an object from an initializer list </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/object/">https://json.nlohmann.me/api/basic_json/object/</a> </dd></dl>

</div>
</div>
<a id="a70e1c8fbdb62f3f8bc04e69eef9cc9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e1c8fbdb62f3f8bc04e69eef9cc9cf">&#9670;&nbsp;</a></span>operator value_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the type of the JSON value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator_value_t/">https://json.nlohmann.me/api/basic_json/operator_value_t/</a> </dd></dl>

</div>
</div>
<a id="a747e3e19891143442991bbdb33edb917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747e3e19891143442991bbdb33edb917">&#9670;&nbsp;</a></span>operator ValueType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , typename std::enable_if&lt; detail::conjunction&lt; detail::negation&lt; std::is_pointer&lt; ValueType &gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, std::nullptr_t &gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, detail::json_ref&lt; basic_json &gt;&gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, typename string_t::value_type &gt;&gt;, detail::negation&lt; detail::is_basic_json&lt; ValueType &gt;&gt;, detail::negation&lt; std::is_same&lt; ValueType, std::initializer_list&lt; typename string_t::value_type &gt;&gt;&gt;, detail::is_detected_lazy&lt; detail::get_template_function, const basic_json_t &amp;, ValueType &gt; &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JSON_EXPLICIT <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator ValueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a value (implicit) </p>
<p>Implicit type conversion between the JSON value and a compatible value. The call is realized by calling <a class="el" href="classbasic__json.html#a0ab31c7fdbab38898070bca01637f886">get() const</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>non-pointer type compatible to the JSON value, for instance <code>int</code> for JSON integer numbers, <code>bool</code> for JSON booleans, or <code>std::vector</code> types for JSON arrays. The character type of <a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> as well as an initializer list of this type is excluded to avoid ambiguities as these types implicitly convert to <code>std::string</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the JSON value, converted to type <em>ValueType</em> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">type_error.302</td><td>in case passed type <em>ValueType</em> is incompatible to the JSON value type (e.g., the JSON value is of type boolean, but a string is requested); see example below</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity Linear in the size of the JSON value.</p>
<p>@liveexample{The example below shows several conversions from JSON values to other types. There a few things to note: (1) Floating-point numbers can be converted to integers\, (2) A JSON array can be converted to a standard <code>std::vector&lt;short&gt;</code>\, (3) A JSON object can be converted to C++ associative containers such as <code>std::unordered_map&lt;std::string\, json&gt;</code>.,operator__ValueType}</p>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

</div>
</div>
<a id="ac444a656905e3f207ad9fc19275faf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac444a656905e3f207ad9fc19275faf25">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

</div>
</div>
<a id="a4475e951f51506808ca6fe7e77eb38ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4475e951f51506808ca6fe7e77eb38ca">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

</div>
</div>
<a id="a996a58d60e4badd9beadfd3e2e7ffdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996a58d60e4badd9beadfd3e2e7ffdc1">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

</div>
</div>
<a id="a3af74b651da5642cd8b77a3ecc635331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af74b651da5642cd8b77a3ecc635331">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

</div>
</div>
<a id="ab0b20f4ac45a0f6e5ac2a2fb6138c19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b20f4ac45a0f6e5ac2a2fb6138c19f">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy assignment </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator=/">https://json.nlohmann.me/api/basic_json/operator=/</a> </dd></dl>

</div>
</div>
<a id="a274307158c76b820701077dd471cc75b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274307158c76b820701077dd471cc75b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="a6aedef6230f66b1271d71a6f77e7fed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aedef6230f66b1271d71a6f77e7fed3">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="a3d3ea17617e94886f3e86ac921095a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3ea17617e94886f3e86ac921095a13">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="a06fe1a1c7aa8c193c73aa40b17ee5f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fe1a1c7aa8c193c73aa40b17ee5f68">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="a2e11a3f2a234cd296b515173b6a3b986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e11a3f2a234cd296b515173b6a3b986">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="ab4f511db82b9d5eba85d5b2b8e1c6dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f511db82b9d5eba85d5b2b8e1c6dbb">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="ae369d1565482903c3af75bf99467776b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae369d1565482903c3af75bf99467776b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2c086af43cf06b1b7118f5351cab3ec9">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="a9c5825034534bf9256a33d2dd995c25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5825034534bf9256a33d2dd995c25a">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">typename object_t::key_type&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

</div>
</div>
<a id="a145a004c0a2fa5be84b260ecc98ab5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145a004c0a2fa5be84b260ecc98ab5d9">&#9670;&nbsp;</a></span>patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::patch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>json_patch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applies a JSON patch to a copy of the current object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/patch/">https://json.nlohmann.me/api/basic_json/patch/</a> </dd></dl>

</div>
</div>
<a id="aca01ca3a9bc310e5c5d067a39dca6933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca01ca3a9bc310e5c5d067a39dca6933">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/push_back/">https://json.nlohmann.me/api/basic_json/push_back/</a> </dd></dl>

</div>
</div>
<a id="af17fe93acad9b0b991600225dabd42be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17fe93acad9b0b991600225dabd42be">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/push_back/">https://json.nlohmann.me/api/basic_json/push_back/</a> </dd></dl>

</div>
</div>
<a id="a4fcacc90f17b156f0b6c8e0430624853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcacc90f17b156f0b6c8e0430624853">&#9670;&nbsp;</a></span>push_back() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a21f7c93f896d302ed0b62d983aac53c0">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/push_back/">https://json.nlohmann.me/api/basic_json/push_back/</a> </dd></dl>

</div>
</div>
<a id="ad018e709338c810c56eaad606186a77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad018e709338c810c56eaad606186a77e">&#9670;&nbsp;</a></span>sax_parse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;typename SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::sax_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdetail_1_1span__input__adapter.html">detail::span_input_adapter</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAX *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code>input_format_t::json</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generate SAX events </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/sax_parse/">https://json.nlohmann.me/api/basic_json/sax_parse/</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This function is deprecated since 3.8.0 and will be removed in version 4.0.0 of the library. Please use sax_parse(ptr, ptr + len) instead. </dd></dl>

</div>
</div>
<a id="a94cbf1844fef86e9301282ad8ca0f822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cbf1844fef86e9301282ad8ca0f822">&#9670;&nbsp;</a></span>sax_parse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , class SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::sax_parse </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAX *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a0ab3b338d0eadc6890b72cccef0ea04f">input_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code>input_format_t::json</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generate SAX events </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/sax_parse/">https://json.nlohmann.me/api/basic_json/sax_parse/</a> </dd></dl>

</div>
</div>
<a id="ac1e32c91d5e641c25c52486341f5a9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e32c91d5e641c25c52486341f5a9db">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a6b282cae56b331d222c7da4b05eab5e8">array_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

</div>
</div>
<a id="a3624e1bbc880bd196e3fa4a220554755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3624e1bbc880bd196e3fa4a220554755">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

</div>
</div>
<a id="abc9ea6dec87e254de172c2bfeaeef7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9ea6dec87e254de172c2bfeaeef7df">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ac90f70623dc1ad761ea1c5013b2fee47">object_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

</div>
</div>
<a id="a1a94e5348ebb34852092d51a44e21d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a94e5348ebb34852092d51a44e21d24">&#9670;&nbsp;</a></span>swap() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

</div>
</div>
<a id="aeac8816c033c659ef8b43a5f03d5f553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac8816c033c659ef8b43a5f03d5f553">&#9670;&nbsp;</a></span>swap() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

</div>
</div>
<a id="aa987625005046c81e7748dca1e84a0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa987625005046c81e7748dca1e84a0e3">&#9670;&nbsp;</a></span>swap() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">typename binary_t::container_type &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

</div>
</div>
<a id="af410354f1c82a34f388e438cc47c31f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af410354f1c82a34f388e438cc47c31f8">&#9670;&nbsp;</a></span>to_bjdata() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::uint8_t&gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_bjdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BJData serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bjdata/">https://json.nlohmann.me/api/basic_json/to_bjdata/</a> </dd></dl>

</div>
</div>
<a id="a1fa9828fcbe4e33c9a036834564f7dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa9828fcbe4e33c9a036834564f7dbd">&#9670;&nbsp;</a></span>to_bjdata() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_bjdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BJData serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bjdata/">https://json.nlohmann.me/api/basic_json/to_bjdata/</a> </dd></dl>

</div>
</div>
<a id="a2736658c256401394059599f97139ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2736658c256401394059599f97139ee9">&#9670;&nbsp;</a></span>to_bjdata() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_bjdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BJData serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bjdata/">https://json.nlohmann.me/api/basic_json/to_bjdata/</a> </dd></dl>

</div>
</div>
<a id="ae0945ada0a9b5afd776b2d6ea2c048a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0945ada0a9b5afd776b2d6ea2c048a5">&#9670;&nbsp;</a></span>to_bson() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::uint8_t&gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bson/">https://json.nlohmann.me/api/basic_json/to_bson/</a> </dd></dl>

</div>
</div>
<a id="a71794547dde3dd67e444aa45131ca861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71794547dde3dd67e444aa45131ca861">&#9670;&nbsp;</a></span>to_bson() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bson/">https://json.nlohmann.me/api/basic_json/to_bson/</a> </dd></dl>

</div>
</div>
<a id="afd718b745034da1f4eea4c69f45cebda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd718b745034da1f4eea4c69f45cebda">&#9670;&nbsp;</a></span>to_bson() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bson/">https://json.nlohmann.me/api/basic_json/to_bson/</a> </dd></dl>

</div>
</div>
<a id="a9bea2fdeaff0956562cafd89fdba9139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bea2fdeaff0956562cafd89fdba9139">&#9670;&nbsp;</a></span>to_cbor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::uint8_t&gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a CBOR serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_cbor/">https://json.nlohmann.me/api/basic_json/to_cbor/</a> </dd></dl>

</div>
</div>
<a id="af31f5ee23264fb21bd31e16bc27adab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31f5ee23264fb21bd31e16bc27adab2">&#9670;&nbsp;</a></span>to_cbor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a CBOR serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_cbor/">https://json.nlohmann.me/api/basic_json/to_cbor/</a> </dd></dl>

</div>
</div>
<a id="a706ccab0e47bd75cd36911db84451cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706ccab0e47bd75cd36911db84451cd1">&#9670;&nbsp;</a></span>to_cbor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a CBOR serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_cbor/">https://json.nlohmann.me/api/basic_json/to_cbor/</a> </dd></dl>

</div>
</div>
<a id="ad317526e90c898957af9ce1c8c011caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad317526e90c898957af9ce1c8c011caa">&#9670;&nbsp;</a></span>to_msgpack() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::uint8_t&gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a MessagePack serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_msgpack/">https://json.nlohmann.me/api/basic_json/to_msgpack/</a> </dd></dl>

</div>
</div>
<a id="a51da13ff4e850d4ad1cf23ce4f3b9e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51da13ff4e850d4ad1cf23ce4f3b9e4a">&#9670;&nbsp;</a></span>to_msgpack() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a MessagePack serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_msgpack/">https://json.nlohmann.me/api/basic_json/to_msgpack/</a> </dd></dl>

</div>
</div>
<a id="af46fdac62559d4c38e623d99ad7064e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46fdac62559d4c38e623d99ad7064e9">&#9670;&nbsp;</a></span>to_msgpack() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a MessagePack serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_msgpack/">https://json.nlohmann.me/api/basic_json/to_msgpack/</a> </dd></dl>

</div>
</div>
<a id="afa6d27aedd29bed0cd145638f4f32fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6d27aedd29bed0cd145638f4f32fdc">&#9670;&nbsp;</a></span>to_ubjson() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::uint8_t&gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a UBJSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_ubjson/">https://json.nlohmann.me/api/basic_json/to_ubjson/</a> </dd></dl>

</div>
</div>
<a id="ab8b6c6cc3ba1b49af628fe0ec8c73b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b6c6cc3ba1b49af628fe0ec8c73b77">&#9670;&nbsp;</a></span>to_ubjson() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a UBJSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_ubjson/">https://json.nlohmann.me/api/basic_json/to_ubjson/</a> </dd></dl>

</div>
</div>
<a id="ada3d71f1dcfea24465d364b815d11445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3d71f1dcfea24465d364b815d11445">&#9670;&nbsp;</a></span>to_ubjson() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdetail_1_1output__adapter.html">detail::output_adapter</a>&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a UBJSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_ubjson/">https://json.nlohmann.me/api/basic_json/to_ubjson/</a> </dd></dl>

</div>
</div>
<a id="ac5e52dbb3cb4e9fcabd1b88c37985aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e52dbb3cb4e9fcabd1b88c37985aef">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the type of the JSON value (explicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/type/">https://json.nlohmann.me/api/basic_json/type/</a> </dd></dl>

</div>
</div>
<a id="afb684c446c48759336dc227f16b7d3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb684c446c48759336dc227f16b7d3f4">&#9670;&nbsp;</a></span>type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JSON_HEDLEY_RETURNS_NON_NULL const char* <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the type as string </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/type_name/">https://json.nlohmann.me/api/basic_json/type_name/</a> </dd></dl>

</div>
</div>
<a id="a4ea2b8cef5e4aba5b92d14e6ebe25936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea2b8cef5e4aba5b92d14e6ebe25936">&#9670;&nbsp;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a1f5af3d9d06d43b91fefe1767794b1e8">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>merge_objects</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updates a JSON object from another object, overwriting existing keys </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/update/">https://json.nlohmann.me/api/basic_json/update/</a> </dd></dl>

</div>
</div>
<a id="a3819f393e82396782ccc22785575b01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3819f393e82396782ccc22785575b01d">&#9670;&nbsp;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a31370bb451b78198d42c86dd31955deb">const_reference</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>merge_objects</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updates a JSON object from another object, overwriting existing keys </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/update/">https://json.nlohmann.me/api/basic_json/update/</a> </dd></dl>

</div>
</div>
<a id="ac63045992eb552c11f77fefddd801591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63045992eb552c11f77fefddd801591">&#9670;&nbsp;</a></span>value() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , detail::enable_if_t&lt; detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element via JSON Pointer with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

</div>
</div>
<a id="a1ab7b5edf8e5831195940f8d377a6ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab7b5edf8e5831195940f8d377a6ee3">&#9670;&nbsp;</a></span>value() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; detail::is_getable&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#afe66720a34c11920f359394a4430a16e">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element via JSON Pointer with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

</div>
</div>
<a id="a80c2436388fd16a1529ce9afce8229ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c2436388fd16a1529ce9afce8229ef">&#9670;&nbsp;</a></span>value() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , detail::enable_if_t&lt; !detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

</div>
</div>
<a id="a56244e0ed0943ad62faf61b06e7ba139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56244e0ed0943ad62faf61b06e7ba139">&#9670;&nbsp;</a></span>value() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; !detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

</div>
</div>
<a id="acbe572bbfbd4687a7a9167465e4d41f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe572bbfbd4687a7a9167465e4d41f2">&#9670;&nbsp;</a></span>value() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class KeyType , detail::enable_if_t&lt; detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;!detail::is_json_pointer&lt; KeyType &gt;::value &amp;&amp;is_comparable_with_object_key&lt; KeyType &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::value </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

</div>
</div>
<a id="a694398741710ce1c22797ad47109898b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694398741710ce1c22797ad47109898b">&#9670;&nbsp;</a></span>value() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class KeyType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; detail::is_transparent&lt; object_comparator_t &gt;::value &amp;&amp;!detail::is_json_pointer&lt; KeyType &gt;::value &amp;&amp;is_comparable_with_object_key&lt; KeyType &gt;::value &amp;&amp;detail::is_getable&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; value_t, detail::uncvref_t&lt; ValueType &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt;::value </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element via JSON Pointer with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a60ca396028b8d9714c6e10efbf475af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ca396028b8d9714c6e10efbf475af6">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator_gtgt/">https://json.nlohmann.me/api/basic_json/operator_gtgt/</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>This stream operator is deprecated since 3.0.0 and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classbasic__json.html#aaf363408931d76472ded14017e59c9e8" title="deserialize from stream">operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</a> instead; that is, replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>. </dd></dl>

</div>
</div>
<a id="aaf363408931d76472ded14017e59c9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf363408931d76472ded14017e59c9e8">&#9670;&nbsp;</a></span>operator&gt;&gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType, CustomBaseClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator_gtgt/">https://json.nlohmann.me/api/basic_json/operator_gtgt/</a> </dd></dl>

</div>
</div>
<a id="a44c98b48b8a0b5e53087776fbb63961f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c98b48b8a0b5e53087776fbb63961f">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;, class CustomBaseClass  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a6ca7bfb35987ce7cb8d27447cda5b80a">reference</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/spiros/Documents/AlgoPlus/third_party/<a class="el" href="json_8hpp_source.html">json.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
